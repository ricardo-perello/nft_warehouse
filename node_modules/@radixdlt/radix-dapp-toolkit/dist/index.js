// src/polyfills.ts
import { Buffer as Buffer2 } from "buffer";
var polyfills_default = () => {
  if (!globalThis.Buffer)
    globalThis.Buffer = Buffer2;
};

// src/modules/connect-button/connect-button.module.ts
import {
  filter as filter6,
  finalize,
  first as first3,
  fromEvent,
  map as map5,
  merge as merge4,
  mergeMap as mergeMap3,
  of as of3,
  Subscription as Subscription6,
  switchMap as switchMap6,
  tap as tap3,
  timer as timer3
} from "rxjs";

// src/modules/connect-button/subjects.ts
import { BehaviorSubject, ReplaySubject, Subject as Subject2 } from "rxjs";

// src/helpers/exponential-backoff.ts
import { err, ok } from "neverthrow";
import { map, merge, of, Subject, switchMap, timer } from "rxjs";
var ExponentialBackoff = ({
  maxDelayTime = 1e4,
  multiplier = 2,
  timeout,
  interval = 2e3
} = {}) => {
  const trigger = new Subject();
  let numberOfRetries = 0;
  const backoff$ = merge(
    of(0),
    trigger.pipe(
      map(() => {
        numberOfRetries = numberOfRetries + 1;
        return numberOfRetries;
      })
    )
  ).pipe(
    switchMap((numberOfRetries2) => {
      const delayTime = numberOfRetries2 * interval * multiplier;
      const delay = delayTime > maxDelayTime ? maxDelayTime : delayTime;
      return timer(delay).pipe(map(() => ok(numberOfRetries2)));
    })
  );
  const withBackoffAndTimeout$ = timeout ? merge(
    backoff$,
    timer(timeout).pipe(map(() => err({ error: "timeout" })))
  ) : backoff$;
  return { trigger, withBackoff$: withBackoffAndTimeout$ };
};

// src/helpers/fetch-wrapper.ts
import { ResultAsync, errAsync, okAsync } from "neverthrow";

// src/helpers/parse-json.ts
import { err as err2, ok as ok2 } from "neverthrow";

// src/helpers/typed-error.ts
var typedError = (error) => error;

// src/helpers/parse-json.ts
var parseJSON = (text) => {
  try {
    return ok2(JSON.parse(text));
  } catch (error) {
    return err2(typedError(error));
  }
};

// src/helpers/fetch-wrapper.ts
var typedError2 = (error) => error;
var resolveFetch = (fetchable) => ResultAsync.fromPromise(fetchable, typedError2).mapErr((error) => ({
  reason: "FailedToFetch",
  error,
  status: 0
}));
var fetchWrapper = (fetchable) => resolveFetch(fetchable).andThen(
  (response) => ResultAsync.fromPromise(response.text(), typedError2).andThen((text) => text ? parseJSON(text) : okAsync(text)).mapErr((error) => ({
    status: response.status,
    reason: "FailedToParseResponseToJson",
    error
  })).andThen(
    (data) => response.ok ? okAsync({
      status: response.status,
      data
    }) : errAsync({
      status: response.status,
      reason: "RequestStatusNotOk",
      data
    })
  )
);

// src/helpers/is-mobile.ts
import Bowser from "bowser";
var isMobile = (userAgent = window.navigator.userAgent) => {
  const parsed = Bowser.parse(userAgent);
  return parsed.platform.type === "mobile" || parsed.platform.type === "tablet";
};

// src/helpers/logger.ts
import { Logger as TsLogger } from "tslog";
var Logger = (minLevel) => new TsLogger({
  minLevel: minLevel ?? 2,
  prettyLogTemplate: "{{hh}}:{{MM}}:{{ss}}:{{ms}}	{{name}}	{{logLevelName}}	"
});

// src/helpers/stringify.ts
import { err as err3, ok as ok3 } from "neverthrow";
var stringify = (input) => {
  try {
    return ok3(JSON.stringify(input));
  } catch (error) {
    return err3(error);
  }
};

// src/helpers/remove-undefined.ts
var removeUndefined = (input) => stringify(input).andThen(parseJSON);

// src/helpers/unwrap-observable.ts
import { ResultAsync as ResultAsync2 } from "neverthrow";
import { firstValueFrom } from "rxjs";
var unwrapObservable = (input) => ResultAsync2.fromPromise(
  firstValueFrom(input),
  (error) => error
).andThen((result) => result);

// src/helpers/validate-wallet-response.ts
import { Result as Result2, errAsync as errAsync2, okAsync as okAsync2 } from "neverthrow";

// src/schemas/index.ts
import {
  array,
  boolean,
  literal,
  number,
  object,
  optional,
  minValue,
  string,
  union,
  merge as merge2,
  custom
} from "valibot";
var Account = object({
  address: string(),
  label: string(),
  appearanceId: number()
});
var Proof = object({
  publicKey: string(),
  signature: string(),
  curve: union([literal("curve25519"), literal("secp256k1")])
});
var AccountProof = object({
  accountAddress: string(),
  proof: Proof
});
var Persona = object({ identityAddress: string(), label: string() });
var personaDataFullNameVariant = {
  western: "western",
  eastern: "eastern"
};
var PersonaDataNameVariant = union([
  literal(personaDataFullNameVariant.eastern),
  literal(personaDataFullNameVariant.western)
]);
var PersonaDataName = object({
  variant: PersonaDataNameVariant,
  familyName: string(),
  nickname: string(),
  givenNames: string()
});
var NumberOfValues = object({
  quantifier: union([literal("exactly"), literal("atLeast")]),
  quantity: number([minValue(0, "The number must be at least 0.")])
});
var AccountsRequestItem = object({
  challenge: optional(string()),
  numberOfAccounts: NumberOfValues
});
var AccountsRequestResponseItem = object(
  {
    accounts: array(Account),
    challenge: optional(string()),
    proofs: optional(array(AccountProof))
  },
  [
    custom((data) => {
      if (data.challenge || data?.proofs) {
        return !!(data.challenge && data?.proofs?.length);
      }
      return true;
    }, "missing challenge or proofs")
  ]
);
var PersonaDataRequestItem = object({
  isRequestingName: optional(boolean()),
  numberOfRequestedEmailAddresses: optional(NumberOfValues),
  numberOfRequestedPhoneNumbers: optional(NumberOfValues)
});
var PersonaDataRequestResponseItem = object({
  name: optional(PersonaDataName),
  emailAddresses: optional(array(string())),
  phoneNumbers: optional(array(string()))
});
var ResetRequestItem = object({
  accounts: boolean(),
  personaData: boolean()
});
var LoginRequestResponseItem = object(
  {
    persona: Persona,
    challenge: optional(string()),
    proof: optional(Proof)
  },
  [
    custom((data) => {
      if (data.challenge || data.proof) {
        return !!(data.challenge && data.proof);
      }
      return true;
    }, "missing challenge or proof")
  ]
);
var WalletUnauthorizedRequestItems = object({
  discriminator: literal("unauthorizedRequest"),
  oneTimeAccounts: optional(AccountsRequestItem),
  oneTimePersonaData: optional(PersonaDataRequestItem)
});
var AuthUsePersonaRequestItem = object({
  discriminator: literal("usePersona"),
  identityAddress: string()
});
var AuthLoginWithoutChallengeRequestItem = object({
  discriminator: literal("loginWithoutChallenge")
});
var AuthLoginWithChallengeRequestItem = object({
  discriminator: literal("loginWithChallenge"),
  challenge: string()
});
var AuthLoginRequestItem = union([
  AuthLoginWithoutChallengeRequestItem,
  AuthLoginWithChallengeRequestItem
]);
var AuthRequestItem = union([
  AuthUsePersonaRequestItem,
  AuthLoginRequestItem
]);
var WalletAuthorizedRequestItems = object({
  discriminator: literal("authorizedRequest"),
  auth: AuthRequestItem,
  reset: optional(ResetRequestItem),
  oneTimeAccounts: optional(AccountsRequestItem),
  ongoingAccounts: optional(AccountsRequestItem),
  oneTimePersonaData: optional(PersonaDataRequestItem),
  ongoingPersonaData: optional(PersonaDataRequestItem)
});
var WalletRequestItems = union([
  WalletUnauthorizedRequestItems,
  WalletAuthorizedRequestItems
]);
var SendTransactionItem = object({
  transactionManifest: string(),
  version: number(),
  blobs: optional(array(string())),
  message: optional(string())
});
var WalletTransactionItems = object({
  discriminator: literal("transaction"),
  send: SendTransactionItem
});
var SendTransactionResponseItem = object({
  transactionIntentHash: string()
});
var WalletTransactionResponseItems = object({
  discriminator: literal("transaction"),
  send: SendTransactionResponseItem
});
var CancelRequest = object({
  discriminator: literal("cancelRequest")
});
var WalletInteractionItems = union([
  WalletRequestItems,
  WalletTransactionItems,
  CancelRequest
]);
var Metadata = object({
  version: literal(2),
  networkId: number(),
  dAppDefinitionAddress: string(),
  origin: string()
});
var WalletInteraction = object({
  interactionId: string(),
  metadata: Metadata,
  items: WalletInteractionItems
});
var WalletUnauthorizedRequestResponseItems = object({
  discriminator: literal("unauthorizedRequest"),
  oneTimeAccounts: optional(AccountsRequestResponseItem),
  oneTimePersonaData: optional(PersonaDataRequestResponseItem)
});
var AuthLoginWithoutChallengeRequestResponseItem = object({
  discriminator: literal("loginWithoutChallenge"),
  persona: Persona
});
var AuthLoginWithChallengeRequestResponseItem = object({
  discriminator: literal("loginWithChallenge"),
  persona: Persona,
  challenge: string(),
  proof: Proof
});
var AuthLoginRequestResponseItem = union([
  AuthLoginWithoutChallengeRequestResponseItem,
  AuthLoginWithChallengeRequestResponseItem
]);
var AuthUsePersonaRequestResponseItem = object({
  discriminator: literal("usePersona"),
  persona: Persona
});
var AuthRequestResponseItem = union([
  AuthUsePersonaRequestResponseItem,
  AuthLoginRequestResponseItem
]);
var WalletAuthorizedRequestResponseItems = object({
  discriminator: literal("authorizedRequest"),
  auth: AuthRequestResponseItem,
  oneTimeAccounts: optional(AccountsRequestResponseItem),
  ongoingAccounts: optional(AccountsRequestResponseItem),
  oneTimePersonaData: optional(PersonaDataRequestResponseItem),
  ongoingPersonaData: optional(PersonaDataRequestResponseItem)
});
var WalletRequestResponseItems = union([
  WalletUnauthorizedRequestResponseItems,
  WalletAuthorizedRequestResponseItems
]);
var WalletInteractionResponseItems = union([
  WalletRequestResponseItems,
  WalletTransactionResponseItems
]);
var WalletInteractionSuccessResponse = object({
  discriminator: literal("success"),
  interactionId: string(),
  items: WalletInteractionResponseItems
});
var WalletInteractionFailureResponse = object({
  discriminator: literal("failure"),
  interactionId: string(),
  error: string(),
  message: optional(string())
});
var WalletInteractionResponse = union([
  WalletInteractionSuccessResponse,
  WalletInteractionFailureResponse
]);
var extensionInteractionDiscriminator = {
  extensionStatus: "extensionStatus",
  openPopup: "openPopup",
  cancelWalletInteraction: "cancelWalletInteraction",
  walletInteraction: "walletInteraction"
};
var StatusExtensionInteraction = object({
  interactionId: string(),
  discriminator: literal(extensionInteractionDiscriminator.extensionStatus)
});
var OpenPopupExtensionInteraction = object({
  interactionId: string(),
  discriminator: literal(extensionInteractionDiscriminator.openPopup)
});
var WalletInteractionExtensionInteraction = object({
  interactionId: string(),
  discriminator: literal(extensionInteractionDiscriminator.walletInteraction),
  interaction: WalletInteraction,
  sessionId: optional(string())
});
var CancelWalletInteractionExtensionInteraction = object({
  interactionId: string(),
  discriminator: literal(
    extensionInteractionDiscriminator.cancelWalletInteraction
  ),
  metadata: Metadata
});
var ExtensionInteraction = union([
  StatusExtensionInteraction,
  OpenPopupExtensionInteraction,
  WalletInteractionExtensionInteraction,
  CancelWalletInteractionExtensionInteraction
]);
var messageLifeCycleEventType = {
  extensionStatus: "extensionStatus",
  receivedByExtension: "receivedByExtension",
  receivedByWallet: "receivedByWallet",
  requestCancelSuccess: "requestCancelSuccess",
  requestCancelFail: "requestCancelFail"
};
var MessageLifeCycleExtensionStatusEvent = object({
  eventType: literal(messageLifeCycleEventType.extensionStatus),
  interactionId: string(),
  isWalletLinked: boolean(),
  isExtensionAvailable: boolean(),
  canHandleSessions: optional(boolean())
});
var MessageLifeCycleEvent = object({
  eventType: union([
    literal(messageLifeCycleEventType.extensionStatus),
    literal(messageLifeCycleEventType.receivedByExtension),
    literal(messageLifeCycleEventType.receivedByWallet),
    literal(messageLifeCycleEventType.requestCancelSuccess),
    literal(messageLifeCycleEventType.requestCancelFail)
  ]),
  interactionId: string()
});
var IncomingMessage = union([
  MessageLifeCycleEvent,
  WalletInteractionResponse
]);
var eventType = {
  outgoingMessage: "radix#chromeExtension#send",
  incomingMessage: "radix#chromeExtension#receive"
};
var Offer = literal("offer");
var Answer = literal("answer");
var IceCandidate = literal("iceCandidate");
var IceCandidates = literal("iceCandidates");
var Types = union([Offer, Answer, IceCandidate, IceCandidates]);
var Sources = union([literal("wallet"), literal("extension")]);
var SignalingServerMessage = object({
  requestId: string(),
  targetClientId: string(),
  encryptedPayload: string(),
  source: optional(Sources),
  // redundant, to be removed
  connectionId: optional(string())
  // redundant, to be removed
});
var AnswerIO = merge2([
  SignalingServerMessage,
  object({
    method: Answer,
    payload: object({
      sdp: string()
    })
  })
]);
var OfferIO = merge2([
  SignalingServerMessage,
  object({
    method: Offer,
    payload: object({
      sdp: string()
    })
  })
]);
var IceCandidatePayloadIO = object({
  candidate: string(),
  sdpMid: string(),
  sdpMLineIndex: number()
});
var IceCandidateIO = merge2([
  SignalingServerMessage,
  object({
    method: IceCandidate,
    payload: IceCandidatePayloadIO
  })
]);
var IceCandidatesIO = merge2([
  SignalingServerMessage,
  object({
    method: IceCandidates,
    payload: array(IceCandidatePayloadIO)
  })
]);

// src/error.ts
var ErrorType = {
  rejectedByUser: "rejectedByUser",
  missingExtension: "missingExtension",
  canceledByUser: "canceledByUser",
  walletRequestValidation: "walletRequestValidation",
  walletResponseValidation: "walletResponseValidation",
  wrongNetwork: "wrongNetwork",
  failedToPrepareTransaction: "failedToPrepareTransaction",
  failedToCompileTransaction: "failedToCompileTransaction",
  failedToSignTransaction: "failedToSignTransaction",
  failedToSubmitTransaction: "failedToSubmitTransaction",
  failedToPollSubmittedTransaction: "failedToPollSubmittedTransaction",
  submittedTransactionWasDuplicate: "submittedTransactionWasDuplicate",
  submittedTransactionHasFailedTransactionStatus: "submittedTransactionHasFailedTransactionStatus",
  submittedTransactionHasRejectedTransactionStatus: "submittedTransactionHasRejectedTransactionStatus",
  failedToFindAccountWithEnoughFundsToLockFee: "failedToFindAccountWithEnoughFundsToLockFee",
  wrongAccountType: "wrongAccountType",
  unknownWebsite: "unknownWebsite",
  radixJsonNotFound: "radixJsonNotFound",
  unknownDappDefinitionAddress: "unknownDappDefinitionAddress",
  invalidPersona: "invalidPersona"
};
var defaultErrorMessage = (/* @__PURE__ */ new Map()).set(ErrorType.missingExtension, "extension could not be found").set(ErrorType.rejectedByUser, "user rejected request").set(ErrorType.canceledByUser, "user has canceled the request");
var SdkError = (error, interactionId, message, jsError) => ({
  error,
  interactionId,
  message: message || defaultErrorMessage.get(error) || "",
  jsError
});

// src/helpers/validate-wallet-response.ts
import { parse } from "valibot";
var validateWalletResponse = (walletResponse) => {
  const fn = Result2.fromThrowable(
    (_) => parse(WalletInteractionResponse, _),
    (error) => error
  );
  const result = fn(walletResponse);
  if (result.isErr()) {
    return errAsync2(SdkError("walletResponseValidation", "", "Invalid input"));
  } else if (result.isOk()) {
    return result.value.discriminator === "success" ? okAsync2(result.value) : errAsync2(result.value);
  }
  return errAsync2(SdkError("walletResponseValidation", ""));
};

// src/helpers/generate-rola-challenge.ts
var generateRolaChallenge = () => [...globalThis.crypto.getRandomValues(new Uint8Array(32))].map((x) => x.toString(16).padStart(2, "0")).join("");

// src/helpers/validate-rola-challenge.ts
var validateRolaChallenge = (challenge) => typeof challenge === "string" && /^[0-9a-f]{64}$/i.test(challenge);

// src/helpers/parse-signed-challenge.ts
import { safeParse } from "valibot";
var parseSignedChallenge = (value) => safeParse(SignedChallenge, value);

// src/modules/connect-button/subjects.ts
var ConnectButtonSubjects = () => ({
  onConnect: new Subject2(),
  onDisconnect: new Subject2(),
  onUpdateSharedAccounts: new Subject2(),
  connected: new ReplaySubject(1),
  requestItems: new BehaviorSubject([]),
  onCancelRequestItem: new Subject2(),
  onIgnoreTransactionItem: new Subject2(),
  accounts: new BehaviorSubject([]),
  onShowPopover: new Subject2(),
  status: new BehaviorSubject("default"),
  loggedInTimestamp: new BehaviorSubject(""),
  isMobile: new BehaviorSubject(isMobile()),
  isWalletLinked: new BehaviorSubject(false),
  showPopoverMenu: new BehaviorSubject(false),
  isExtensionAvailable: new BehaviorSubject(false),
  fullWidth: new BehaviorSubject(false),
  activeTab: new BehaviorSubject("sharing"),
  mode: new BehaviorSubject("light"),
  theme: new BehaviorSubject("radix-blue"),
  avatarUrl: new BehaviorSubject(""),
  personaLabel: new BehaviorSubject(""),
  personaData: new BehaviorSubject([]),
  dAppName: new BehaviorSubject(""),
  onLinkClick: new Subject2()
});

// src/modules/wallet-request/crypto/curve25519.ts
import { x25519, ed25519 } from "@noble/curves/ed25519";
import { Buffer as Buffer3 } from "buffer";
import { err as err4, ok as ok4 } from "neverthrow";

// ../../node_modules/@noble/hashes/esm/_assert.js
function number2(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`positive integer expected, not ${n}`);
}
function isBytes(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function bytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function hash(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number2(h.outputLen);
  number2(h.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// ../../node_modules/@noble/hashes/esm/utils.js
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  bytes(data);
  return data;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr = {}.toString;
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}

// ../../node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash2);
    const key = toBytes(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash2.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
hmac.create = (hash2, key) => new HMAC(hash2, key);

// ../../node_modules/@noble/hashes/esm/hkdf.js
function extract(hash2, ikm, salt) {
  hash(hash2);
  if (salt === void 0)
    salt = new Uint8Array(hash2.outputLen);
  return hmac(hash2, toBytes(salt), toBytes(ikm));
}
var HKDF_COUNTER = /* @__PURE__ */ new Uint8Array([0]);
var EMPTY_BUFFER = /* @__PURE__ */ new Uint8Array();
function expand(hash2, prk, info, length = 32) {
  hash(hash2);
  number2(length);
  if (length > 255 * hash2.outputLen)
    throw new Error("Length should be <= 255*HashLen");
  const blocks = Math.ceil(length / hash2.outputLen);
  if (info === void 0)
    info = EMPTY_BUFFER;
  const okm = new Uint8Array(blocks * hash2.outputLen);
  const HMAC2 = hmac.create(hash2, prk);
  const HMACTmp = HMAC2._cloneInto();
  const T = new Uint8Array(HMAC2.outputLen);
  for (let counter = 0; counter < blocks; counter++) {
    HKDF_COUNTER[0] = counter + 1;
    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);
    okm.set(T, hash2.outputLen * counter);
    HMAC2._cloneInto(HMACTmp);
  }
  HMAC2.destroy();
  HMACTmp.destroy();
  T.fill(0);
  HKDF_COUNTER.fill(0);
  return okm.slice(0, length);
}
var hkdf = (hash2, ikm, salt, info, length) => expand(hash2, extract(hash2, ikm, salt), info, length);

// ../../node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
var Chi = (a, b, c) => a & b ^ ~a & c;
var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// ../../node_modules/@noble/hashes/esm/sha256.js
var SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());

// src/modules/wallet-request/crypto/curve25519.ts
var toHex = (input) => Buffer3.from(input).toString("hex");
var Curve25519 = (privateKeyHex = toHex(x25519.utils.randomPrivateKey())) => {
  const getPrivateKey = () => privateKeyHex;
  const x25519Api = {
    getPublicKey: () => toHex(x25519.getPublicKey(privateKeyHex)),
    calculateSharedSecret: (publicKeyHex, dAppDefinitionAddress) => {
      try {
        const sharedSecret = x25519.getSharedSecret(privateKeyHex, publicKeyHex);
        const derived = hkdf(
          sha256,
          sharedSecret,
          Buffer3.from(dAppDefinitionAddress, "utf-8"),
          "RCfM",
          32
        );
        return ok4(toHex(derived));
      } catch (error) {
        return err4(error);
      }
    }
  };
  const ed25519Api = {
    getPublicKey: () => toHex(ed25519.getPublicKey(privateKeyHex)),
    sign: (messageHex) => {
      try {
        return ok4(toHex(ed25519.sign(messageHex, privateKeyHex)));
      } catch (error) {
        return err4(error);
      }
    }
  };
  return {
    getPrivateKey,
    x25519: x25519Api,
    ed25519: ed25519Api
  };
};

// src/modules/wallet-request/crypto/blake2b.ts
import { err as err5, ok as ok5 } from "neverthrow";
import blake from "blakejs";
import { Buffer as Buffer4 } from "buffer";
var bufferToArrayBuffer = (buffer) => {
  const arrayBuffer = new ArrayBuffer(buffer.length);
  const view = new Uint8Array(arrayBuffer);
  for (let i = 0; i < buffer.length; ++i) {
    view[i] = buffer[i];
  }
  return arrayBuffer;
};
var bufferToUnit8Array = (buffer) => new Uint8Array(bufferToArrayBuffer(buffer));
var blake2b = (input) => {
  try {
    return ok5(blake.blake2bHex(bufferToUnit8Array(input), void 0, 32)).map(
      (hex) => Buffer4.from(hex, "hex")
    );
  } catch (error) {
    return err5(error);
  }
};

// src/modules/wallet-request/data-request/builders/accounts.ts
import { produce } from "immer";
import { boolean as boolean2, object as object2, optional as optional2 } from "valibot";
var AccountsDataRequestSchema = object2({
  numberOfAccounts: NumberOfValues,
  withProof: optional2(boolean2()),
  reset: optional2(boolean2())
});
var accounts = () => {
  const defaultValue = {
    numberOfAccounts: { quantifier: "atLeast", quantity: 1 }
  };
  let data = produce(defaultValue, () => {
  });
  const atLeast = (n) => {
    data = produce(data, (draft) => {
      draft.numberOfAccounts.quantifier = "atLeast";
      draft.numberOfAccounts.quantity = n;
    });
    return methods;
  };
  const exactly = (n) => {
    data = produce(data, (draft) => {
      draft.numberOfAccounts.quantifier = "exactly";
      draft.numberOfAccounts.quantity = n;
    });
    return methods;
  };
  const reset = (value = true) => {
    data = produce(data, (draft) => {
      draft.reset = value;
    });
    return methods;
  };
  const withProof = (value = true) => {
    data = produce(data, (draft) => {
      draft.withProof = value;
    });
    return methods;
  };
  const _toObject = () => ({
    accounts: data
  });
  const methods = {
    atLeast,
    exactly,
    withProof,
    reset,
    _toObject
  };
  return methods;
};

// src/modules/wallet-request/data-request/builders/persona.ts
import { produce as produce2 } from "immer";
import { boolean as boolean3, object as object3, optional as optional3 } from "valibot";
var schema = object3({
  withProof: optional3(boolean3())
});
var persona = (initialData = {
  withProof: false
}) => {
  let data = produce2(initialData, () => {
  });
  const withProof = (value = true) => {
    data = produce2(data, (draft) => {
      draft.withProof = value;
    });
    return methods;
  };
  const _toObject = () => ({
    persona: data
  });
  const methods = {
    withProof,
    _toObject
  };
  return methods;
};

// src/modules/wallet-request/data-request/builders/persona-data.ts
import { produce as produce3 } from "immer";
import { boolean as boolean4, object as object4, partial } from "valibot";
var PersonaDataRequestSchema = partial(
  object4({
    fullName: boolean4(),
    emailAddresses: NumberOfValues,
    phoneNumbers: NumberOfValues,
    reset: boolean4()
  })
);
var personaData = (initialData = {}) => {
  let data = produce3(initialData, () => {
  });
  const fullName = (value = true) => {
    data = produce3(data, (draft) => {
      draft.fullName = value;
    });
    return methods;
  };
  const createNumberOfValuesOptions = (key) => ({
    atLeast: (n) => {
      data = produce3(data, (draft) => {
        draft[key] = { quantifier: "atLeast", quantity: n };
      });
      return methods;
    },
    exactly: (n) => {
      data = produce3(data, (draft) => {
        draft[key] = { quantifier: "exactly", quantity: n };
      });
      return methods;
    }
  });
  const emailAddresses = (value = true) => {
    const options = createNumberOfValuesOptions("emailAddresses");
    options.exactly(value ? 1 : 0);
    return methods;
  };
  const phoneNumbers = (value = true) => {
    const options = createNumberOfValuesOptions("phoneNumbers");
    options.exactly(value ? 1 : 0);
    return methods;
  };
  const reset = (value = true) => {
    data = produce3(data, (draft) => {
      draft.reset = value;
    });
    return methods;
  };
  const _toObject = () => ({
    personaData: data
  });
  const methods = {
    fullName,
    emailAddresses,
    phoneNumbers,
    reset,
    _toObject
  };
  return methods;
};

// src/modules/wallet-request/data-request/builders/index.ts
var config = (data) => {
  const _toObject = () => ({ ...data });
  const methods = {
    _toObject
  };
  return methods;
};
var DataRequestBuilder = {
  accounts,
  personaData,
  persona,
  config
};
var OneTimeDataRequestBuilder = {
  accounts,
  personaData
};

// src/helpers/is-deep-equal.ts
var isDeepEqual = (a, b) => {
  const values = [null, void 0, false, true];
  if (values.includes(a) || values.includes(b) || typeof a === "number" || typeof b === "number") {
    return Object.is(a, b);
  }
  const aKeys = Object.keys(a);
  const bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length)
    return false;
  for (const key of aKeys) {
    const value1 = a[key];
    const value2 = b[key];
    const isObjects = isObject(value1) && isObject(value2);
    if (isObjects && !isDeepEqual(value1, value2) || !isObjects && value1 !== value2) {
      return false;
    }
  }
  return true;
};
var isObject = (x) => {
  return x != null && typeof x === "object";
};

// src/modules/wallet-request/data-request/helpers/can-data-request-be-resolved-by-rdt-state.ts
var canDataRequestBeResolvedByRdtState = (dataRequest, state) => {
  if (dataRequest.discriminator === "authorizedRequest") {
    const isReset = dataRequest.reset?.accounts || dataRequest.reset?.personaData;
    const isOneTimeRequest = !!(dataRequest.oneTimeAccounts || dataRequest.oneTimePersonaData);
    const isChallengeRequest = dataRequest.auth.discriminator === "loginWithChallenge" || !!dataRequest.oneTimeAccounts?.challenge || !!dataRequest.ongoingAccounts?.challenge;
    if (isReset || isOneTimeRequest || isChallengeRequest)
      return false;
    let rdtStateSatisfiesRequest = false;
    if (dataRequest.ongoingAccounts) {
      const { quantifier, quantity } = dataRequest.ongoingAccounts.numberOfAccounts;
      rdtStateSatisfiesRequest = state.sharedData?.ongoingAccounts?.numberOfAccounts?.quantifier === quantifier && state.sharedData?.ongoingAccounts?.numberOfAccounts?.quantity === quantity;
    }
    if (dataRequest.ongoingPersonaData) {
      rdtStateSatisfiesRequest = isDeepEqual(
        dataRequest.ongoingPersonaData,
        state.sharedData?.ongoingPersonaData
      );
    }
    return rdtStateSatisfiesRequest;
  }
  return false;
};

// src/modules/wallet-request/data-request/helpers/to-wallet-request.ts
import { produce as produce5 } from "immer";

// src/modules/wallet-request/data-request/transformations/rdt-to-wallet.ts
import { produce as produce4 } from "immer";
import { ok as ok6 } from "neverthrow";
import { boolean as boolean5, object as object5, string as string2, optional as optional4 } from "valibot";
var TransformRdtDataRequestToWalletRequestInput = object5({
  accounts: optional4(
    object5({
      numberOfAccounts: NumberOfValues,
      reset: boolean5(),
      oneTime: boolean5(),
      challenge: optional4(string2())
    })
  ),
  personaData: optional4(
    object5({
      fullName: optional4(boolean5()),
      phoneNumbers: optional4(NumberOfValues),
      emailAddresses: optional4(NumberOfValues),
      reset: boolean5(),
      oneTime: optional4(boolean5())
    })
  ),
  persona: optional4(
    object5({
      identityAddress: optional4(string2()),
      label: optional4(string2()),
      challenge: optional4(string2())
    })
  )
});
var isAuthorized = (input) => {
  const { persona: persona2, accounts: accounts2, personaData: personaData2 } = input;
  const isPersonaLogin = !!persona2;
  const shouldResetData = accounts2?.reset || personaData2?.reset;
  const isOngoingAccountsRequest = accounts2 && !accounts2?.oneTime;
  const isOngoingPersonaDataRequest = personaData2 && !personaData2?.oneTime;
  const isAuthorizedRequest = !!(shouldResetData || isOngoingAccountsRequest || isOngoingPersonaDataRequest || isPersonaLogin);
  return isAuthorizedRequest;
};
var createLoginRequestItem = (input) => {
  if (input.persona?.challenge) {
    return {
      discriminator: "loginWithChallenge",
      challenge: input.persona.challenge
    };
  }
  if (input.persona?.identityAddress) {
    return {
      discriminator: "usePersona",
      identityAddress: input.persona?.identityAddress
    };
  }
  return {
    discriminator: "loginWithoutChallenge"
  };
};
var withAccountRequestItem = (input) => (requestItems) => {
  const updatedRequestItems = { ...requestItems };
  const { accounts: accounts2 } = input;
  if (accounts2) {
    const data = {
      challenge: accounts2.challenge,
      numberOfAccounts: accounts2.numberOfAccounts
    };
    const isOngoingRequest = updatedRequestItems.discriminator === "authorizedRequest" && !input.accounts?.oneTime;
    const isConnectOngoingRequest = updatedRequestItems.discriminator === "authorizedRequest";
    if (input.accounts?.oneTime) {
      updatedRequestItems["oneTimeAccounts"] = data;
    } else if (isOngoingRequest || isConnectOngoingRequest) {
      updatedRequestItems["ongoingAccounts"] = data;
    }
  }
  return updatedRequestItems;
};
var withPersonaDataRequestItem = (input) => (requestItems) => {
  const updatedRequestItems = { ...requestItems };
  if (input.personaData) {
    const {
      fullName: isRequestingName,
      phoneNumbers: numberOfRequestedPhoneNumbers,
      emailAddresses: numberOfRequestedEmailAddresses
    } = input.personaData;
    if (input.personaData?.oneTime) {
      updatedRequestItems["oneTimePersonaData"] = {
        isRequestingName,
        numberOfRequestedPhoneNumbers,
        numberOfRequestedEmailAddresses
      };
    }
    const isOngoingRequest = updatedRequestItems.discriminator === "authorizedRequest" && !input.personaData?.oneTime;
    const isConnectOngoingRequest = updatedRequestItems.discriminator === "authorizedRequest";
    if (isOngoingRequest || isConnectOngoingRequest) {
      updatedRequestItems["ongoingPersonaData"] = {
        isRequestingName,
        numberOfRequestedPhoneNumbers,
        numberOfRequestedEmailAddresses
      };
    }
  }
  return updatedRequestItems;
};
var withResetRequestItem = (input) => (requestItems) => {
  const { accounts: accounts2, personaData: personaData2 } = input;
  return {
    ...requestItems,
    reset: { accounts: !!accounts2?.reset, personaData: !!personaData2?.reset }
  };
};
var createUnauthorizedRequestItems = (input) => ok6({
  discriminator: "unauthorizedRequest"
}).map(withAccountRequestItem(input)).map(withPersonaDataRequestItem(input));
var createAuthorizedRequestItems = (input) => ok6({
  discriminator: "authorizedRequest",
  auth: createLoginRequestItem(input)
}).map(withAccountRequestItem(input)).map(withPersonaDataRequestItem(input)).map(withResetRequestItem(input));
var transformConnectRequest = (isConnect, input) => ok6(
  isConnect ? produce4(input, (draft) => {
    if (draft.accounts) {
      draft.accounts.oneTime = false;
      draft.accounts.reset = false;
    }
    if (draft.personaData) {
      draft.personaData.oneTime = false;
      draft.personaData.reset = false;
    }
  }) : input
);
var transformRdtDataRequestToWalletRequest = (isConnect, input) => transformConnectRequest(isConnect, input).andThen(
  (transformed) => isAuthorized(transformed) ? createAuthorizedRequestItems(transformed) : createUnauthorizedRequestItems(transformed)
);

// src/modules/wallet-request/data-request/helpers/to-wallet-request.ts
var toWalletRequest = ({
  dataRequestState,
  isConnect,
  challenge,
  oneTime,
  walletData
}) => transformRdtDataRequestToWalletRequest(
  isConnect,
  produce5({}, (draft) => {
    if (dataRequestState.accounts) {
      draft.accounts = {
        numberOfAccounts: dataRequestState.accounts.numberOfAccounts || {
          quantifier: "atLeast",
          quantity: 1
        },
        oneTime,
        reset: !!dataRequestState.accounts.reset,
        challenge: dataRequestState.accounts.withProof ? challenge : void 0
      };
    }
    if (dataRequestState.personaData)
      draft.personaData = {
        ...dataRequestState.personaData,
        reset: !!dataRequestState.personaData.reset,
        oneTime
      };
    if (!oneTime) {
      const persona2 = walletData.persona;
      if (walletData.persona)
        draft.persona = persona2;
      if (dataRequestState.persona?.withProof)
        draft.persona = { ...draft.persona ?? {}, challenge };
      if (Object.values(dataRequestState).length === 0)
        draft.persona = { challenge: void 0 };
    }
  })
);

// src/modules/wallet-request/data-request/transformations/shared-data.ts
import { produce as produce6 } from "immer";
var transformWalletRequestToSharedData = (walletInteraction, sharedData) => {
  const { items: walletDataRequest } = walletInteraction;
  if (walletDataRequest.discriminator === "authorizedRequest")
    return produce6({}, (draft) => {
      draft.persona = { proof: false };
      if (walletDataRequest.auth.discriminator === "loginWithChallenge")
        draft.persona.proof = !!walletDataRequest.auth.challenge;
      if (walletDataRequest.ongoingAccounts) {
        draft.ongoingAccounts = {
          proof: !!walletDataRequest.ongoingAccounts.challenge,
          numberOfAccounts: walletDataRequest.ongoingAccounts.numberOfAccounts
        };
      }
      if (walletDataRequest.ongoingPersonaData) {
        draft.ongoingPersonaData = walletDataRequest.ongoingPersonaData;
      }
    });
  return sharedData;
};
var transformSharedDataToDataRequestState = (sharedData) => produce6({}, (draft) => {
  if (sharedData.ongoingAccounts) {
    draft.accounts = {
      numberOfAccounts: sharedData.ongoingAccounts.numberOfAccounts,
      withProof: sharedData.ongoingAccounts.proof,
      reset: true
    };
  }
  if (sharedData.ongoingPersonaData) {
    draft.personaData = {
      fullName: sharedData.ongoingPersonaData.isRequestingName,
      phoneNumbers: sharedData.ongoingPersonaData.numberOfRequestedPhoneNumbers,
      emailAddresses: sharedData.ongoingPersonaData.numberOfRequestedEmailAddresses,
      reset: false
    };
  }
  if (sharedData.persona) {
    draft.persona = {
      withProof: false
    };
  }
});

// src/modules/wallet-request/data-request/transformations/wallet-to-rdt.ts
import { produce as produce7 } from "immer";
import { okAsync as okAsync4 } from "neverthrow";

// src/modules/state/state.module.ts
import { BehaviorSubject as BehaviorSubject2, Subscription, filter } from "rxjs";

// src/modules/state/types.ts
import {
  array as array2,
  boolean as boolean6,
  optional as optional5,
  literal as literal2,
  object as object6,
  variant,
  string as string3
} from "valibot";
var proofType = {
  persona: "persona",
  account: "account"
};
var SignedChallengePersona = object6({
  challenge: string3(),
  proof: Proof,
  address: string3(),
  type: literal2(proofType.persona)
});
var SignedChallengeAccount = object6({
  challenge: string3(),
  proof: Proof,
  address: string3(),
  type: literal2(proofType.account)
});
var SignedChallenge = variant("type", [
  SignedChallengePersona,
  SignedChallengeAccount
]);
var WalletDataPersonaDataFullName = object6({
  entry: literal2("fullName"),
  fields: PersonaDataName
});
var WalletDataPersonaDataEmailAddresses = object6({
  entry: literal2("emailAddresses"),
  fields: array2(string3())
});
var WalletDataPersonaDataPhoneNumbersAddresses = object6({
  entry: literal2("phoneNumbers"),
  fields: array2(string3())
});
var WalletDataPersonaData = variant("entry", [
  WalletDataPersonaDataFullName,
  WalletDataPersonaDataEmailAddresses,
  WalletDataPersonaDataPhoneNumbersAddresses
]);
var WalletData = object6({
  accounts: array2(Account),
  personaData: array2(WalletDataPersonaData),
  persona: optional5(Persona),
  proofs: array2(SignedChallenge)
});
var SharedData = object6({
  persona: optional5(object6({ proof: boolean6() })),
  ongoingAccounts: optional5(
    object6({
      numberOfAccounts: optional5(NumberOfValues),
      proof: boolean6()
    })
  ),
  ongoingPersonaData: optional5(PersonaDataRequestItem)
});
var RdtState = object6({
  loggedInTimestamp: string3(),
  walletData: WalletData,
  sharedData: SharedData
});
var walletDataDefault = {
  accounts: [],
  personaData: [],
  proofs: [],
  persona: void 0
};

// src/modules/state/state.module.ts
import { ok as ok7, okAsync as okAsync3 } from "neverthrow";
var StateModule = (input) => {
  const logger = input?.logger?.getSubLogger({ name: "StateModule" });
  const storageModule = input.providers.storageModule;
  const subscriptions = new Subscription();
  const setState = (state) => storageModule.setState(state);
  const getState = () => storageModule.getState().orElse(() => okAsync3(defaultState)).andThen((state) => state ? ok7(state) : ok7(defaultState));
  const patchState = (state) => getState().andThen((oldState) => setState({ ...oldState, ...state }));
  const defaultState = {
    walletData: walletDataDefault,
    loggedInTimestamp: "",
    sharedData: {}
  };
  const resetState = () => storageModule.setState(defaultState).map(() => {
    emitWalletData();
  });
  const initializeState = () => getState().map(() => emitWalletData()).orElse(() => resetState());
  initializeState();
  const walletDataSubject = new BehaviorSubject2(
    void 0
  );
  const emitWalletData = () => {
    storageModule.getState().map((state) => {
      walletDataSubject.next(state?.walletData);
    });
  };
  const walletData$ = walletDataSubject.asObservable().pipe(filter((walletData) => !!walletData));
  return {
    setState,
    patchState,
    getState,
    walletData$,
    emitWalletData,
    getWalletData: () => walletDataSubject.value,
    reset: resetState,
    storage$: storageModule.storage$,
    destroy: () => {
      subscriptions.unsubscribe();
    }
  };
};

// src/modules/wallet-request/data-request/transformations/wallet-to-rdt.ts
var withAccounts = (input) => (walletData) => {
  let accounts2 = [];
  if (input.discriminator === "authorizedRequest") {
    const oneTimeAccounts = input.oneTimeAccounts?.accounts ?? [];
    const ongoingAccounts = input.ongoingAccounts?.accounts ?? [];
    accounts2 = [...oneTimeAccounts, ...ongoingAccounts];
  } else if (input.discriminator === "unauthorizedRequest") {
    const oneTimeAccounts = input.oneTimeAccounts?.accounts ?? [];
    accounts2 = oneTimeAccounts;
  }
  return produce7(walletData, (draft) => {
    draft.accounts = accounts2;
  });
};
var withPersonaDataEntries = (input) => {
  const entries = [];
  if (input.name) {
    entries.push({
      entry: "fullName",
      fields: input.name
    });
  }
  if (input.emailAddresses)
    entries.push({
      entry: "emailAddresses",
      fields: input.emailAddresses
    });
  if (input.phoneNumbers)
    entries.push({
      entry: "phoneNumbers",
      fields: input.phoneNumbers
    });
  return entries;
};
var withPersonaData = (input) => (walletData) => produce7(walletData, (draft) => {
  if (input.discriminator === "authorizedRequest") {
    if (input.oneTimePersonaData)
      draft.personaData = withPersonaDataEntries(input.oneTimePersonaData);
    if (input.ongoingPersonaData)
      draft.personaData = withPersonaDataEntries(input.ongoingPersonaData);
  } else if (input.discriminator === "unauthorizedRequest" && input.oneTimePersonaData)
    draft.personaData = withPersonaDataEntries(input.oneTimePersonaData);
});
var withPersona = (input) => (walletData) => produce7(walletData, (draft) => {
  if (input.discriminator === "authorizedRequest")
    draft.persona = input.auth?.persona;
});
var withProofs = (input) => (walletData) => produce7(walletData, (draft) => {
  draft.proofs = [];
  if (input.discriminator === "authorizedRequest") {
    if (input.auth.discriminator === "loginWithChallenge")
      draft.proofs.push({
        challenge: input.auth.challenge,
        proof: input.auth.proof,
        address: input.auth.persona.identityAddress,
        type: proofType.persona
      });
    if (input.ongoingAccounts?.challenge && input.ongoingAccounts.proofs?.length) {
      const challenge = input.ongoingAccounts.challenge;
      const accountProofs = input.ongoingAccounts.proofs.map(
        ({ accountAddress, proof }) => ({
          proof,
          address: accountAddress,
          challenge,
          type: proofType.account
        })
      );
      draft.proofs.push(...accountProofs);
    }
    if (input.oneTimeAccounts?.challenge && input.oneTimeAccounts.proofs?.length) {
      const challenge = input.oneTimeAccounts.challenge;
      const accountProofs = input.oneTimeAccounts.proofs.map(
        ({ accountAddress, proof }) => ({
          proof,
          address: accountAddress,
          challenge,
          type: proofType.account
        })
      );
      draft.proofs.push(...accountProofs);
    }
  }
  if (input.discriminator === "unauthorizedRequest") {
    if (input.oneTimeAccounts?.challenge && input.oneTimeAccounts.proofs?.length) {
      const challenge = input.oneTimeAccounts.challenge;
      const accountProofs = input.oneTimeAccounts.proofs.map(
        ({ accountAddress, proof }) => ({
          proof,
          address: accountAddress,
          challenge,
          type: proofType.account
        })
      );
      draft.proofs.push(...accountProofs);
    }
  }
});
var transformWalletResponseToRdtWalletData = (response) => okAsync4({
  accounts: [],
  personaData: [],
  proofs: [],
  persona: void 0
}).map(withAccounts(response)).map(withPersonaData(response)).map(withPersona(response)).map(withProofs(response));

// src/modules/wallet-request/data-request/transformations/wallet-data-to-connect-button.ts
var transformWalletDataToConnectButton = (walletData) => {
  const accounts2 = walletData.accounts ?? [];
  const personaLabel = walletData?.persona?.label ?? "";
  const connected = !!walletData?.persona;
  const personaData2 = walletData?.personaData?.map((item) => {
    if (item.entry === "fullName") {
      const { variant: variant2, givenNames, familyName, nickname } = item.fields;
      const value = variant2 === "western" ? `${givenNames}${nickname ? ` "${nickname}" ` : " "}${familyName}` : `${familyName}${nickname ? ` "${nickname}" ` : " "}${givenNames}`;
      return {
        value,
        field: "fullName"
      };
    } else if (item.entry === "emailAddresses") {
      return {
        // currently only one email address is supported
        value: item.fields[0],
        field: "emailAddress"
      };
    } else if (item.entry === "phoneNumbers") {
      return {
        // currently only one phone number is supported
        value: item.fields[0],
        field: "phoneNumber"
      };
    }
    return;
  }).filter(
    (item) => !!item && !!item.value?.trim()
  );
  return { accounts: accounts2, personaLabel, connected, personaData: personaData2 };
};

// src/modules/wallet-request/data-request/data-request-state.module.ts
import { BehaviorSubject as BehaviorSubject3 } from "rxjs";
import { produce as produce8 } from "immer";
var DataRequestStateModule = (initialState) => {
  const state = new BehaviorSubject3(initialState);
  const reset = () => state.next(initialState);
  const update = (input) => state.next(input);
  const getState = () => state.getValue();
  const toDataRequestState = (...items) => items.filter((item) => typeof item._toObject === "function").reduce(
    (acc, item) => ({
      ...acc,
      ...item._toObject()
    }),
    {}
  );
  const setState = (...items) => {
    if (items.length === 0)
      reset();
    else {
      update(toDataRequestState(...items));
    }
  };
  const patchState = (...items) => {
    if (items.length === 0)
      return;
    update({ ...getState(), ...toDataRequestState(...items) });
  };
  const removeState = (...keys) => {
    update(
      produce8(getState(), (draft) => {
        keys.forEach((key) => {
          delete draft[key];
        });
      })
    );
  };
  return {
    reset,
    setState,
    getState,
    patchState,
    removeState,
    toDataRequestState,
    state$: state.asObservable()
  };
};

// src/modules/wallet-request/identity/identity.module.ts
import { err as err6, ok as ok8, okAsync as okAsync5 } from "neverthrow";

// src/modules/wallet-request/crypto/create-signature-message.ts
import { Buffer as Buffer5 } from "buffer";
var createSignatureMessage = ({
  interactionId,
  dAppDefinitionAddress,
  origin,
  logger
}) => {
  const prefix = "C";
  const prefixBuffer = Buffer5.from("C", "ascii");
  const lengthOfDappDefAddress = dAppDefinitionAddress.length;
  const lengthOfDappDefAddressBuffer = Buffer5.from(
    lengthOfDappDefAddress.toString(16),
    "hex"
  );
  const dappDefAddressBuffer = Buffer5.from(dAppDefinitionAddress, "utf-8");
  const originBuffer = Buffer5.from(origin, "utf-8");
  const interactionIdBuffer = Buffer5.from(interactionId, "utf-8");
  const messageBuffer = Buffer5.concat([
    prefixBuffer,
    interactionIdBuffer,
    lengthOfDappDefAddressBuffer,
    dappDefAddressBuffer,
    originBuffer
  ]);
  const blake2bHash = blake2b(messageBuffer).map((hash2) => {
    logger?.debug({
      method: "createSignatureMessage",
      messagePartsRaw: [
        prefix,
        interactionId,
        lengthOfDappDefAddress,
        dAppDefinitionAddress,
        origin
      ],
      messageParts: [
        prefixBuffer.toString("hex"),
        interactionIdBuffer.toString("hex"),
        lengthOfDappDefAddressBuffer.toString("hex"),
        dappDefAddressBuffer.toString("hex"),
        originBuffer.toString("hex")
      ],
      message: messageBuffer.toString("hex"),
      blake2bHash: hash2.toString("hex")
    });
    return Buffer5.from(hash2).toString("hex");
  }).mapErr((jsError) => ({ reason: "couldNotHashMessage", jsError }));
  return blake2bHash;
};

// src/modules/wallet-request/identity/identity.module.ts
var IdentityKind = {
  dApp: "dApp"
};
var IdentityModule = (input) => {
  const { storageModule, KeyPairModule } = input.providers;
  const keyPairFromSecret = (input2) => ok8(KeyPairModule(input2));
  const getIdentity = (kind) => storageModule.getItemById(kind).andThen(
    (identity) => identity ? keyPairFromSecret(identity.secret) : okAsync5(void 0)
  );
  const createIdentity = (kind) => ok8(KeyPairModule()).asyncAndThen(
    (keyPair) => storageModule.setItems({
      [kind]: {
        secret: keyPair.getPrivateKey(),
        createdAt: Date.now()
      }
    }).map(() => keyPair)
  );
  const getOrCreateIdentity = (kind) => getIdentity(kind).andThen((keyPair) => keyPair ? okAsync5(keyPair) : createIdentity(kind)).mapErr((error) => ({
    reason: "couldNotGetOrCreateIdentity",
    jsError: error
  }));
  const deriveSharedSecret = (kind, publicKey) => getIdentity(kind).mapErr(() => ({ reason: "couldNotDeriveSharedSecret" })).andThen(
    (identity) => identity ? identity.x25519.calculateSharedSecret(publicKey, input.dAppDefinitionAddress).mapErr(() => ({
      reason: "FailedToDeriveSharedSecret"
    })) : err6({ reason: "DappIdentityNotFound" })
  );
  const createSignature = ({
    kind,
    interactionId,
    dAppDefinitionAddress,
    origin
  }) => getOrCreateIdentity(kind).andThen(
    (identity) => createSignatureMessage({
      interactionId,
      dAppDefinitionAddress,
      origin,
      logger: input.logger
    }).andThen(
      (message) => identity.ed25519.sign(message).map((signature) => ({
        signature,
        publicKey: identity.x25519.getPublicKey(),
        identity: identity.ed25519.getPublicKey()
      })).mapErr((error) => ({
        reason: "couldNotSignMessage",
        jsError: error
      }))
    )
  );
  return {
    get: (kind) => getOrCreateIdentity(kind),
    deriveSharedSecret,
    createSignature
  };
};

// ../common/src/index.ts
var RequestStatus = {
  pending: "pending",
  success: "success",
  fail: "fail",
  cancelled: "cancelled",
  ignored: "ignored"
};

// src/modules/wallet-request/request-items/request-item.module.ts
import { Subscription as Subscription2, filter as filter2, map as map2, switchMap as switchMap2 } from "rxjs";
import { errAsync as errAsync3 } from "neverthrow";
var RequestItemModule = (input) => {
  const logger = input?.logger?.getSubLogger({ name: "RequestItemModule" });
  const subscriptions = new Subscription2();
  const storageModule = input.providers.storageModule;
  const createItem = ({
    type,
    walletInteraction,
    isOneTimeRequest
  }) => ({
    type,
    status: "pending",
    createdAt: Date.now(),
    interactionId: walletInteraction.interactionId,
    showCancel: true,
    walletInteraction,
    isOneTimeRequest
  });
  const add = (value) => {
    const item = createItem(value);
    logger?.debug({
      method: "addRequestItem",
      item
    });
    return storageModule.setItems({ [item.interactionId]: item }).map(() => item);
  };
  const patch = (id, partialValue) => {
    logger?.debug({
      method: "patchRequestItemStatus",
      item: { id, ...partialValue }
    });
    return storageModule.patchItem(id, partialValue);
  };
  const cancel = (id) => {
    logger?.debug({ method: "cancelRequestItem", id });
    return patch(id, { status: "fail", error: ErrorType.canceledByUser });
  };
  const updateStatus = ({
    id,
    status,
    error,
    transactionIntentHash
  }) => {
    return storageModule.getItemById(id).mapErr(() => ({ reason: "couldNotReadFromStore" })).andThen((item) => {
      if (item) {
        const updated = {
          ...item,
          status: item.status === RequestStatus.ignored ? item.status : status
        };
        if (updated.status === "fail") {
          updated.error = error;
        }
        if (updated.status === "success" && updated.type === "sendTransaction") {
          updated.transactionIntentHash = transactionIntentHash;
        }
        if (["success", "fail", "ignored", "cancelled"].includes(updated.status)) {
          delete updated.walletInteraction;
          delete updated.walletResponse;
        }
        logger?.debug({ method: "updateRequestItemStatus", updated });
        return storageModule.setItems({ [id]: updated }).mapErr(() => ({ reason: "couldNotWriteToStore" }));
      }
      return errAsync3({ reason: "itemNotFound" });
    });
  };
  const getPending = () => storageModule.getItemList().map((items) => items.filter((item) => item.status === "pending"));
  const requests$ = storageModule.storage$.pipe(
    switchMap2(() => storageModule.getItemList()),
    map2((result) => {
      if (result.isOk())
        return result.value;
    }),
    filter2((items) => !!items)
  );
  return {
    add,
    cancel,
    updateStatus,
    patch,
    getById: (id) => storageModule.getItemById(id),
    getPending,
    requests$,
    clear: storageModule.clear,
    destroy: () => {
      subscriptions.unsubscribe();
    }
  };
};

// src/modules/wallet-request/session/session.module.ts
import { okAsync as okAsync6 } from "neverthrow";
import { v4 as uuidV4 } from "uuid";
var SessionModule = (input) => {
  const storageModule = input.providers.storageModule;
  const getSession = () => storageModule.getItemList().mapErr((error) => ({
    reason: "couldNotReadSessionFromStore",
    jsError: error
  })).map((sessions) => sessions[0]);
  const getSessionById = (sessionId) => storageModule.getItemById(sessionId).mapErr((error) => ({ reason: "couldNotGetSessionById", jsError: error }));
  const createSession = () => {
    const sessionId = uuidV4();
    const newSession = {
      sessionId,
      createdAt: Date.now()
    };
    return storageModule.setItems({ [sessionId]: newSession }).map(() => newSession).mapErr((error) => ({ reason: "couldNotCreateSession", jsError: error }));
  };
  const patchSession = (sessionId, value) => storageModule.patchItem(sessionId, value).mapErr((error) => ({ reason: "couldNotPatchSession", jsError: error }));
  const getCurrentSession = () => getSession().andThen(
    (session) => session ? okAsync6(session) : createSession()
  );
  return {
    getCurrentSession,
    getSession,
    store: storageModule,
    getSessionById,
    patchSession
  };
};

// src/modules/wallet-request/transport/connector-extension/subjects.ts
import { Subject as Subject3 } from "rxjs";
var ConnectorExtensionSubjects = () => ({
  outgoingMessageSubject: new Subject3(),
  incomingMessageSubject: new Subject3(),
  responseSubject: new Subject3(),
  messageLifeCycleEventSubject: new Subject3()
});

// src/modules/wallet-request/transport/connector-extension/connector-extension.module.ts
import { ResultAsync as ResultAsync6, err as err7, ok as ok9, okAsync as okAsync7 } from "neverthrow";
import {
  Subject as Subject4,
  Subscription as Subscription3,
  filter as filter3,
  first,
  firstValueFrom as firstValueFrom2,
  map as map3,
  merge as merge3,
  mergeMap,
  of as of2,
  race,
  share,
  shareReplay,
  switchMap as switchMap3,
  takeUntil,
  tap,
  timer as timer2
} from "rxjs";
import { v4 as uuidV42 } from "uuid";
var ConnectorExtensionModule = (input) => {
  let isExtensionHandlingSessions = false;
  const logger = input?.logger?.getSubLogger({
    name: "ConnectorExtensionModule"
  });
  const subjects = input?.subjects ?? ConnectorExtensionSubjects();
  const subscription = new Subscription3();
  const extensionDetectionTime = input?.extensionDetectionTime ?? 200;
  const requestItemModule = input.providers.requestItemModule;
  const storage = input.providers.storageModule.getPartition("connectorExtension");
  subscription.add(
    subjects.incomingMessageSubject.pipe(
      tap((message) => {
        logger?.debug({
          method: "incomingMessageSubject",
          message
        });
        if ("eventType" in message) {
          subjects.messageLifeCycleEventSubject.next(message);
        } else {
          subjects.responseSubject.next(message);
        }
      })
    ).subscribe()
  );
  subscription.add(
    subjects.outgoingMessageSubject.pipe(
      tap((payload) => {
        logger?.debug({
          method: "outgoingMessageSubject",
          payload
        });
        window.dispatchEvent(
          new CustomEvent(eventType.outgoingMessage, {
            detail: payload
          })
        );
      })
    ).subscribe()
  );
  const wrapOutgoingInteraction = (interaction) => {
    if (!isExtensionHandlingSessions) {
      return okAsync7(interaction);
    }
    return storage.getState().andThen((state) => {
      const isAuthorizedRequest = interaction.items.discriminator === "authorizedRequest";
      const sessionId = isAuthorizedRequest ? state?.sessionId || uuidV42() : state?.sessionId;
      const wrappedRequest = {
        interactionId: interaction.interactionId,
        interaction,
        sessionId,
        discriminator: "walletInteraction"
      };
      return isAuthorizedRequest ? storage.setState({ sessionId }).map(() => wrappedRequest) : okAsync7(wrappedRequest);
    });
  };
  const handleIncomingMessage = (event) => {
    const message = event.detail;
    subjects.incomingMessageSubject.next(message);
  };
  addEventListener(eventType.incomingMessage, handleIncomingMessage);
  const sendWalletInteraction = (walletInteraction, callbackFns) => {
    const cancelRequestSubject = new Subject4();
    const walletResponse$ = subjects.responseSubject.pipe(
      filter3(
        (response) => response.interactionId === walletInteraction.interactionId
      ),
      mergeMap(
        (walletResponse) => requestItemModule.patch(walletResponse.interactionId, {
          walletResponse
        }).mapErr(
          () => SdkError("requestItemPatchError", walletResponse.interactionId)
        ).map(() => walletResponse)
      )
    );
    const cancelResponse$ = subjects.messageLifeCycleEventSubject.pipe(
      filter3(
        ({ interactionId, eventType: eventType2 }) => walletInteraction.interactionId === interactionId && ["requestCancelSuccess", "requestCancelFail"].includes(eventType2)
      ),
      map3((message) => {
        const error = SdkError("canceledByUser", message.interactionId);
        logger?.debug(`\u{1F535}\u2B06\uFE0F\u274C walletRequestCanceled`, error);
        return message;
      })
    );
    const sendCancelRequest = () => {
      subjects.outgoingMessageSubject.next({
        interactionId: walletInteraction.interactionId,
        metadata: walletInteraction.metadata,
        ...isExtensionHandlingSessions ? { discriminator: "cancelWalletInteraction" } : { items: { discriminator: "cancelRequest" } }
      });
      setTimeout(() => {
        cancelRequestSubject.next(
          err7(SdkError("canceledByUser", walletInteraction.interactionId))
        );
      });
      return ResultAsync6.fromSafePromise(
        firstValueFrom2(
          merge3(
            walletResponse$.pipe(map3(() => "requestCancelFail")),
            cancelResponse$.pipe(map3(({ eventType: eventType2 }) => eventType2))
          )
        )
      );
    };
    if (callbackFns.requestControl)
      callbackFns.requestControl({
        cancelRequest: () => sendCancelRequest().andThen(
          (eventType2) => eventType2 === "requestCancelSuccess" ? ok9("requestCancelSuccess") : err7("requestCancelFail")
        ),
        getRequest: () => walletInteraction
      });
    const walletResponseOrCancelRequest$ = merge3(
      walletResponse$,
      cancelRequestSubject
    ).pipe(first());
    const messageLifeCycleEvent$ = subjects.messageLifeCycleEventSubject.pipe(
      filter3(
        ({ interactionId }) => walletInteraction.interactionId === interactionId
      ),
      tap((event) => {
        if (callbackFns.eventCallback)
          callbackFns.eventCallback(event.eventType);
      }),
      takeUntil(walletResponse$),
      share()
    );
    const messageEventSubscription = messageLifeCycleEvent$.subscribe();
    const missingExtensionError$ = timer2(extensionDetectionTime).pipe(
      map3(
        () => err7(SdkError("missingExtension", walletInteraction.interactionId))
      )
    );
    const extensionMissingError$ = merge3(
      missingExtensionError$,
      messageLifeCycleEvent$
    ).pipe(
      first(),
      filter3((value) => !("eventType" in value))
    );
    const sendWalletRequest$ = extensionStatus$.pipe(
      filter3((status) => status.isExtensionAvailable),
      switchMap3(() => of2(wrapOutgoingInteraction(walletInteraction))),
      tap((result) => {
        result.map((message) => {
          subjects.outgoingMessageSubject.next(message);
        });
      }),
      filter3((_) => false)
    );
    return unwrapObservable(
      merge3(
        walletResponseOrCancelRequest$,
        extensionMissingError$,
        sendWalletRequest$
      ).pipe(
        tap(() => {
          messageEventSubscription.unsubscribe();
        })
      )
    );
  };
  const extensionStatusEvent$ = subjects.messageLifeCycleEventSubject.pipe(
    filter3(
      (event) => event.eventType === "extensionStatus"
    )
  );
  const extensionStatus$ = of2(true).pipe(
    tap(() => {
      subjects.outgoingMessageSubject.next({
        interactionId: uuidV42(),
        discriminator: "extensionStatus"
      });
    }),
    switchMap3(
      () => race(
        extensionStatusEvent$,
        merge3(
          extensionStatusEvent$,
          timer2(extensionDetectionTime).pipe(
            map3(
              () => ({
                eventType: "extensionStatus",
                isWalletLinked: false,
                isExtensionAvailable: false,
                canHandleSessions: false
              })
            )
          )
        )
      )
    ),
    tap((event) => {
      isExtensionHandlingSessions = event.canHandleSessions || false;
    }),
    shareReplay(1)
  );
  return {
    id: "connector-extension",
    isSupported: () => !isMobile(),
    send: sendWalletInteraction,
    isAvailable$: extensionStatus$.pipe(
      map3(({ isExtensionAvailable }) => isExtensionAvailable)
    ),
    isLinked$: extensionStatus$.pipe(
      map3(({ isWalletLinked }) => isWalletLinked)
    ),
    showQrCode: () => {
      window.dispatchEvent(
        new CustomEvent(eventType.outgoingMessage, {
          detail: { discriminator: "openPopup" }
        })
      );
    },
    disconnect: () => {
      storage.clear();
    },
    destroy: () => {
      subscription.unsubscribe();
      removeEventListener(eventType.incomingMessage, handleIncomingMessage);
    }
  };
};

// src/modules/wallet-request/transport/radix-connect-relay/deep-link.module.ts
import { errAsync as errAsync4, okAsync as okAsync8 } from "neverthrow";
import Bowser2 from "bowser";
var DeepLinkModule = (input) => {
  const { walletUrl } = input;
  const userAgent = Bowser2.parse(window.navigator.userAgent);
  const { platform } = userAgent;
  const logger = input?.logger?.getSubLogger({ name: "DeepLinkModule" });
  logger?.debug({
    platform,
    userAgent: window.navigator.userAgent,
    userAgentParsed: userAgent
  });
  const deepLinkToWallet = (values) => {
    const outboundUrl = new URL(walletUrl);
    Object.entries(values).forEach(([key, value]) => {
      outboundUrl.searchParams.append(key, value);
    });
    logger?.debug({
      method: "deepLinkToWallet",
      data: { ...values }
    });
    if (isMobile() && globalThis.location?.href) {
      globalThis.location.href = outboundUrl.toString();
      return okAsync8(void 0);
    }
    return errAsync4(SdkError("UnhandledEnvironment", ""));
  };
  return {
    deepLinkToWallet
  };
};

// src/modules/wallet-request/transport/radix-connect-relay/radix-connect-relay.module.ts
import { ResultAsync as ResultAsync8, err as err9, errAsync as errAsync5, ok as ok11, okAsync as okAsync9 } from "neverthrow";
import { Subscription as Subscription4 } from "rxjs";

// src/modules/wallet-request/encryption/helpers/buffer-reader.ts
import { err as err8, ok as ok10 } from "neverthrow";
import { Buffer as Buffer6 } from "buffer";
var createBufferReader = (buffer) => {
  let offset = 0;
  let bytesLeftToRead = buffer.length;
  const readNextBuffer = (byteCount) => {
    if (byteCount < 0)
      return err8(Error(`'byteCount' must not be negative`));
    if (byteCount === 0) {
      return ok10(Buffer6.alloc(0));
    }
    if (offset + byteCount > buffer.length)
      return err8(Error(`Out of buffer's boundary`));
    const bufToReturn = Buffer6.alloc(byteCount);
    buffer.copy(bufToReturn, 0, offset, offset + byteCount);
    if (bufToReturn.length !== byteCount) {
      return err8(Error(`Incorrect length of newly read buffer...`));
    }
    offset += byteCount;
    bytesLeftToRead -= byteCount;
    return ok10(bufToReturn);
  };
  const finishedParsing = () => {
    if (bytesLeftToRead < 0) {
      return err8(Error(`Incorrect implementation, read too many bytes.`));
    }
    return ok10(bytesLeftToRead === 0);
  };
  return {
    readNextBuffer,
    finishedParsing,
    remainingBytes: () => finishedParsing().andThen((finished) => {
      if (finished)
        return ok10(Buffer6.alloc(0));
      const leftBuf = Buffer6.alloc(bytesLeftToRead);
      buffer.copy(leftBuf, 0, offset);
      return ok10(leftBuf);
    })
  };
};
var readBuffer = (buffer) => createBufferReader(buffer).readNextBuffer;

// src/modules/wallet-request/encryption/helpers/sealbox.ts
import { Buffer as Buffer7 } from "buffer";
import { Result as Result5 } from "neverthrow";
var combineSealboxToBuffer = ({
  iv,
  ciphertext,
  authTag
}) => Buffer7.concat([iv, ciphertext, authTag]);
var combineCiphertextAndAuthtag = ({
  ciphertext,
  authTag
}) => Buffer7.concat([ciphertext, authTag]);
var transformBufferToSealbox = (buffer) => {
  const readNextBuffer = readBuffer(buffer);
  const nonceLength = 12;
  const authTagLength = 16;
  return Result5.combine([
    readNextBuffer(nonceLength),
    readNextBuffer(buffer.length - nonceLength - authTagLength),
    readNextBuffer(authTagLength)
  ]).map(([iv, ciphertext, authTag]) => ({
    iv,
    ciphertext,
    authTag,
    combined: combineSealboxToBuffer({ iv, ciphertext, authTag }),
    ciphertextAndAuthTag: combineCiphertextAndAuthtag({
      ciphertext,
      authTag
    })
  }));
};

// src/modules/wallet-request/encryption/encryption.module.ts
import { ResultAsync as ResultAsync7 } from "neverthrow";
import { Buffer as Buffer8 } from "buffer";
var EncryptionModule = () => {
  const cryptoDecrypt = (data, encryptionKey, iv) => ResultAsync7.fromPromise(
    crypto.subtle.decrypt({ name: "AES-GCM", iv }, encryptionKey, data),
    typedError
  ).map(Buffer8.from);
  const cryptoEncrypt = (data, encryptionKey, iv) => ResultAsync7.fromPromise(
    crypto.subtle.encrypt(
      {
        name: "AES-GCM",
        iv
      },
      encryptionKey,
      data
    ),
    typedError
  ).map(Buffer8.from);
  const getKey = (encryptionKey) => ResultAsync7.fromPromise(
    crypto.subtle.importKey(
      "raw",
      encryptionKey,
      {
        name: "AES-GCM",
        length: 256
      },
      false,
      ["encrypt", "decrypt"]
    ),
    typedError
  );
  const combineIVandCipherText = (iv, ciphertext) => Buffer8.concat([iv, ciphertext]);
  const decrypt = (data, encryptionKey, iv) => getKey(encryptionKey).andThen(
    (cryptoKey) => cryptoDecrypt(data, cryptoKey, iv)
  );
  const encrypt = (data, encryptionKey, iv = createIV()) => getKey(encryptionKey).andThen((cryptoKey) => cryptoEncrypt(data, cryptoKey, iv)).map((ciphertext) => ({
    combined: combineIVandCipherText(iv, ciphertext),
    iv,
    ciphertext
  }));
  const createIV = () => Buffer8.from(crypto.getRandomValues(new Uint8Array(12)));
  return { encrypt, decrypt, createIV };
};

// src/modules/wallet-request/transport/radix-connect-relay/radix-connect-relay-api.service.ts
var RadixConnectRelayApiService = (input) => {
  const baseUrl = input.baseUrl;
  const logger = input.logger?.getSubLogger({ name: "RadixConnectRelayApi" });
  const callApi = (body) => {
    logger?.debug({ method: `callApi.${body.method}`, body });
    return fetchWrapper(
      fetch(baseUrl, {
        method: "POST",
        body: JSON.stringify(body)
      })
    ).map((response) => {
      logger?.debug({
        method: `callApi.${body.method}.success`,
        response
      });
      return response;
    }).mapErr((error) => {
      logger?.debug({
        method: `callApi.${body.method}.error`,
        error
      });
      return SdkError(
        "RadixConnectRelayRequestFailed",
        body.interactionId ?? ""
      );
    });
  };
  const getResponses = (sessionId) => callApi({
    method: "getResponses",
    sessionId
  }).map((value) => value.data);
  return {
    getResponses
  };
};

// src/modules/wallet-request/transport/radix-connect-relay/helpers/base64url.ts
import base64url from "base64url";
var base64urlEncode = (value) => base64url.encode(Buffer.from(JSON.stringify(value)));

// src/modules/wallet-request/transport/radix-connect-relay/radix-connect-relay.module.ts
var RadixConnectRelayModule = (input) => {
  const logger = input.logger?.getSubLogger({ name: "RadixConnectRelayModule" });
  const { baseUrl, providers, walletUrl } = input;
  const { requestItemModule, storageModule } = providers;
  const walletResponses = storageModule.getPartition("walletResponses");
  const encryptionModule = providers?.encryptionModule ?? EncryptionModule();
  const deepLinkModule = providers?.deepLinkModule ?? DeepLinkModule({
    logger,
    walletUrl
  });
  const identityModule = providers?.identityModule ?? IdentityModule({
    logger,
    dAppDefinitionAddress: input.dAppDefinitionAddress,
    providers: {
      storageModule: storageModule.getPartition("identities"),
      KeyPairModule: Curve25519
    }
  });
  const sessionModule = providers?.sessionModule ?? SessionModule({
    providers: {
      storageModule: storageModule.getPartition("sessions")
    }
  });
  const radixConnectRelayApiService = RadixConnectRelayApiService({
    baseUrl: `${baseUrl}/api/v1`,
    logger
  });
  const subscriptions = new Subscription4();
  const wait = (timer4 = 1500) => new Promise((resolve) => setTimeout(resolve, timer4));
  const decryptWalletResponse = (walletResponse) => {
    if ("error" in walletResponse) {
      return errAsync5({ reason: walletResponse.error });
    }
    return identityModule.get("dApp").andThen(
      (dAppIdentity) => dAppIdentity.x25519.calculateSharedSecret(
        walletResponse.publicKey,
        input.dAppDefinitionAddress
      ).mapErr(() => ({ reason: "FailedToDeriveSharedSecret" })).asyncAndThen(
        (sharedSecret) => decryptWalletResponseData(sharedSecret, walletResponse.data)
      )
    );
  };
  const checkRelayLoop = async () => {
    await requestItemModule.getPending().andThen((pendingItems) => {
      if (pendingItems.length === 0) {
        return okAsync9(void 0);
      }
      return sessionModule.getCurrentSession().andThen(
        (session) => radixConnectRelayApiService.getResponses(session.sessionId)
      ).andThen(
        (responses) => ResultAsync8.combine(
          responses.map((response) => decryptWalletResponse(response))
        ).andThen((decryptedResponses) => {
          return walletResponses.setItems(
            decryptedResponses.reduce(
              (acc, response) => {
                acc[response.interactionId] = response;
                return acc;
              },
              {}
            )
          );
        })
      );
    });
    await wait();
    checkRelayLoop();
  };
  if (isMobile()) {
    checkRelayLoop();
  }
  const sendWalletInteractionRequest = ({
    session,
    walletInteraction,
    signature,
    publicKey,
    identity
  }) => requestItemModule.getById(walletInteraction.interactionId).mapErr(
    () => SdkError("FailedToGetPendingItems", walletInteraction.interactionId)
  ).andThen(
    (pendingItem) => pendingItem ? ok11(pendingItem) : err9(
      SdkError("PendingItemNotFound", walletInteraction.interactionId)
    )
  ).andThen(
    () => requestItemModule.patch(walletInteraction.interactionId, { sentToWallet: true }).andThen(
      () => deepLinkModule.deepLinkToWallet({
        sessionId: session.sessionId,
        request: base64urlEncode(walletInteraction),
        signature,
        publicKey,
        identity,
        origin: walletInteraction.metadata.origin,
        dAppDefinitionAddress: walletInteraction.metadata.dAppDefinitionAddress
      })
    )
  ).mapErr(
    () => SdkError("FailedToSendDappRequest", walletInteraction.interactionId)
  );
  const sendToWallet = (walletInteraction, callbackFns) => ResultAsync8.combine([
    sessionModule.getCurrentSession().mapErr(
      (error) => SdkError(error.reason, walletInteraction.interactionId)
    ),
    identityModule.get("dApp").mapErr(
      (error) => SdkError(error.reason, walletInteraction.interactionId)
    )
  ]).andThen(
    ([session, dAppIdentity]) => identityModule.createSignature({
      dAppDefinitionAddress: walletInteraction.metadata.dAppDefinitionAddress,
      interactionId: walletInteraction.interactionId,
      origin: walletInteraction.metadata.origin,
      kind: "dApp"
    }).mapErr(
      (error) => SdkError(error.reason, walletInteraction.interactionId)
    ).andThen(
      ({ signature }) => sendWalletInteractionRequest({
        session,
        walletInteraction,
        signature,
        identity: dAppIdentity.ed25519.getPublicKey(),
        publicKey: dAppIdentity.x25519.getPublicKey()
      })
    ).andThen(() => waitForWalletResponse(walletInteraction.interactionId))
  );
  const decryptWalletResponseData = (sharedSecretHex, value) => transformBufferToSealbox(Buffer.from(value, "hex")).asyncAndThen(
    ({ ciphertextAndAuthTag, iv }) => encryptionModule.decrypt(
      ciphertextAndAuthTag,
      Buffer.from(sharedSecretHex, "hex"),
      iv
    )
  ).andThen(
    (decrypted) => parseJSON(decrypted.toString("utf-8"))
  ).mapErr((error) => ({
    reason: "FailedToDecryptWalletResponseData",
    jsError: error
  }));
  const waitForWalletResponse = (interactionId) => ResultAsync8.fromPromise(
    new Promise(async (resolve, reject) => {
      let response;
      let error;
      logger?.debug({
        method: "waitForWalletResponse",
        interactionId
      });
      while (!response) {
        const requestItemResult = await requestItemModule.getById(interactionId);
        if (requestItemResult.isOk()) {
          logger?.trace({
            method: "waitForWalletResponse.requestItemResult",
            requestItemResult: requestItemResult.value
          });
          if (requestItemResult.value?.status !== "pending") {
            error = SdkError(
              "RequestItemNotPending",
              interactionId,
              "request not in pending state"
            );
            break;
          }
        }
        const walletResponse = await walletResponses.getItemById(interactionId);
        if (walletResponse.isOk()) {
          if (walletResponse.value) {
            response = walletResponse.value;
            await walletResponses.removeItemById(interactionId);
            await requestItemModule.patch(interactionId, {
              walletResponse: walletResponse.value
            });
          }
        }
        if (!response) {
          await wait();
        }
      }
      return response ? resolve(response) : reject(error);
    }),
    (err14) => err14
  );
  return {
    id: "radix-connect-relay",
    isSupported: () => isMobile(),
    send: sendToWallet,
    disconnect: () => {
    },
    destroy: () => {
      subscriptions.unsubscribe();
    }
  };
};

// src/modules/wallet-request/wallet-request-sdk.ts
import { ResultAsync as ResultAsync9, err as err10, ok as ok12 } from "neverthrow";
import { parse as parse2 } from "valibot";
import { v4 as uuidV43 } from "uuid";
var WalletRequestSdk = (input) => {
  const metadata = {
    version: 2,
    dAppDefinitionAddress: input.dAppDefinitionAddress,
    networkId: input.networkId,
    origin: input.origin || window.location.origin
  };
  parse2(Metadata, metadata);
  const logger = input?.logger?.getSubLogger({ name: "WalletSdk" });
  const availableTransports = input.providers.transports;
  const requestInterceptorDefault = async (walletInteraction) => walletInteraction;
  const requestInterceptor = input.requestInterceptor ?? requestInterceptorDefault;
  logger?.debug({ metadata });
  const createWalletInteraction = (items, interactionId = uuidV43()) => ({
    items,
    interactionId,
    metadata
  });
  const withInterceptor = (payload) => ResultAsync9.fromPromise(
    requestInterceptor(payload),
    (error) => SdkError("requestInterceptorError", payload.interactionId, error.message)
  );
  const getTransport = (interactionId) => {
    const transport = availableTransports.find(
      (transport2) => transport2.isSupported()
    );
    return transport ? ok12(transport) : err10({
      error: "SupportedTransportNotFound",
      interactionId,
      message: "No supported transport found"
    });
  };
  const request = ({
    interactionId = uuidV43(),
    items
  }, callbackFns = {}) => withInterceptor({
    items,
    interactionId,
    metadata
  }).andThen(
    (walletInteraction) => getTransport(walletInteraction.interactionId).asyncAndThen(
      (transport) => transport.send(walletInteraction, callbackFns).andThen(validateWalletResponse)
    )
  );
  const sendTransaction = ({
    interactionId = uuidV43(),
    items
  }, callbackFns = {}) => withInterceptor({
    interactionId,
    items,
    metadata
  }).andThen(
    (walletInteraction) => getTransport(interactionId).asyncAndThen(
      (transport) => transport.send(walletInteraction, callbackFns).andThen(validateWalletResponse)
    )
  );
  return {
    request,
    sendTransaction,
    createWalletInteraction,
    getTransport
  };
};

// src/modules/wallet-request/wallet-request.ts
import {
  Subject as Subject5,
  Subscription as Subscription5,
  filter as filter5,
  firstValueFrom as firstValueFrom4,
  map as map4,
  mergeMap as mergeMap2,
  switchMap as switchMap5,
  tap as tap2
} from "rxjs";

// src/modules/gateway/types.ts
var TransactionStatus = {
  Unknown: "Unknown",
  CommittedSuccess: "CommittedSuccess",
  CommittedFailure: "CommittedFailure",
  Pending: "Pending",
  Rejected: "Rejected"
};
var RadixNetwork = {
  Mainnet: 1,
  Stokenet: 2,
  Gilganet: 32,
  Enkinet: 33,
  Hammunet: 34,
  Nergalnet: 35,
  Mardunet: 36,
  Dumunet: 37
};
var RadixNetworkConfig = {
  Mainnet: {
    networkName: "Mainnet",
    networkId: RadixNetwork.Mainnet,
    gatewayUrl: "https://mainnet.radixdlt.com",
    dashboardUrl: "https://dashboard.radixdlt.com"
  },
  Stokenet: {
    networkName: "Stokenet",
    networkId: RadixNetwork.Stokenet,
    gatewayUrl: "https://babylon-stokenet-gateway.radixdlt.com",
    dashboardUrl: "https://stokenet-dashboard.radixdlt.com"
  },
  Mardunet: {
    networkName: "Mardunet",
    networkId: RadixNetwork.Mardunet,
    gatewayUrl: "https://mardunet-gateway.radixdlt.com",
    dashboardUrl: "https://mardunet-dashboard.rdx-works-main.extratools.works"
  },
  Gilganet: {
    networkName: "Gilganet",
    networkId: RadixNetwork.Gilganet,
    gatewayUrl: "https://gilganet-gateway.radixdlt.com",
    dashboardUrl: "https://gilganet-dashboard.rdx-works-main.extratools.works"
  },
  Enkinet: {
    networkName: "Enkinet",
    networkId: RadixNetwork.Enkinet,
    gatewayUrl: "https://enkinet-gateway.radixdlt.com",
    dashboardUrl: "https://enkinet-dashboard.rdx-works-main.extratools.works"
  },
  Hammunet: {
    networkName: "Hammunet",
    networkId: RadixNetwork.Hammunet,
    gatewayUrl: "https://hammunet-gateway.radixdlt.com",
    dashboardUrl: "https://hammunet-dashboard.rdx-works-main.extratools.works"
  },
  Dumunet: {
    networkName: "Dumunet",
    networkId: RadixNetwork.Dumunet,
    gatewayUrl: "https://dumunet-gateway.radixdlt.com",
    dashboardUrl: "https://dumunet-dashboard.rdx-works-main.extratools.works"
  }
};
var RadixNetworkConfigById = Object.values(RadixNetworkConfig).reduce(
  (prev, config2) => {
    prev[config2.networkId] = config2;
    return prev;
  },
  {}
);

// src/modules/gateway/helpers/generate-gateway-api-config.ts
var generateGatewayApiConfig = ({
  networkId,
  dAppDefinitionAddress,
  gatewayBaseUrl,
  applicationName,
  applicationVersion
}) => ({
  basePath: gatewayBaseUrl ?? RadixNetworkConfigById[networkId].gatewayUrl,
  applicationName: applicationName ?? "Unknown",
  applicationVersion: applicationVersion ?? "Unknown",
  applicationDappDefinitionAddress: dAppDefinitionAddress
});

// src/version.ts
var __VERSION__ = "2.1.1";

// src/modules/gateway/gateway.service.ts
var GatewayApiService = ({
  basePath,
  applicationName,
  applicationVersion,
  applicationDappDefinitionAddress
}) => {
  const fetchWithHeaders = (url, body) => fetchWrapper(
    fetch(`${basePath}${url}`, {
      method: "POST",
      body: JSON.stringify(body),
      headers: {
        "Content-Type": "application/json",
        "RDX-Client-Name": "@radixdlt/radix-dapp-toolkit",
        "RDX-Client-Version": __VERSION__,
        "RDX-App-Name": applicationName,
        "RDX-App-Version": applicationVersion,
        "RDX-App-Dapp-Definition": applicationDappDefinitionAddress
      }
    })
  ).map((response) => response.data);
  const getTransactionStatus = (transactionIntentHash) => fetchWithHeaders("/transaction/status", {
    intent_hash: transactionIntentHash
  });
  const getEntityMetadataPage = (address) => fetchWithHeaders("/state/entity/page/metadata", { address });
  return {
    getTransactionStatus,
    getEntityMetadataPage
  };
};

// src/modules/gateway/gateway.module.ts
import { ResultAsync as ResultAsync10, err as err11, ok as ok13 } from "neverthrow";
import { filter as filter4, first as first2, firstValueFrom as firstValueFrom3, switchMap as switchMap4 } from "rxjs";
var GatewayModule = (input) => {
  const logger = input.logger?.getSubLogger({ name: "GatewayModule" });
  const gatewayApi = input?.providers?.gatewayApiService ?? GatewayApiService(input.clientConfig);
  const pollTransactionStatus = (transactionIntentHash) => {
    const retry = ExponentialBackoff(input.retryConfig);
    const completedTransactionStatus = /* @__PURE__ */ new Set([
      "CommittedSuccess",
      "CommittedFailure",
      "Rejected"
    ]);
    return ResultAsync10.fromPromise(
      firstValueFrom3(
        retry.withBackoff$.pipe(
          switchMap4((result) => {
            if (result.isErr())
              return [
                err11(
                  SdkError("failedToPollSubmittedTransaction", "", void 0, {
                    error: result.error,
                    context: "GatewayModule.pollTransactionStatus.retry.withBackoff$",
                    transactionIntentHash
                  })
                )
              ];
            logger?.debug(`pollingTxStatus retry #${result.value + 1}`);
            return gatewayApi.getTransactionStatus(transactionIntentHash).map((response) => {
              if (completedTransactionStatus.has(response.status))
                return response;
              retry.trigger.next();
              return;
            }).orElse((response) => {
              if (response.reason === "FailedToFetch") {
                logger?.debug({
                  error: response,
                  context: "unexpected error, retrying"
                });
                retry.trigger.next();
                return ok13(void 0);
              }
              logger?.debug(response);
              return err11(
                SdkError("failedToPollSubmittedTransaction", "", void 0, {
                  error: response,
                  transactionIntentHash,
                  context: "GatewayModule.pollTransactionStatus.getTransactionStatus"
                })
              );
            });
          }),
          filter4(
            (result) => result.isOk() && !!result.value || result.isErr()
          ),
          first2()
        )
      ),
      (error) => error
    ).andThen((result) => result);
  };
  return {
    pollTransactionStatus,
    gatewayApi,
    configuration: input.clientConfig
  };
};

// src/modules/wallet-request/wallet-request.ts
import { ResultAsync as ResultAsync11, err as err12, ok as ok14, okAsync as okAsync10 } from "neverthrow";
var WalletRequestModule = (input) => {
  const logger = input.logger?.getSubLogger({ name: "WalletRequestModule" });
  const useCache = input.useCache;
  const networkId = input.networkId;
  const cancelRequestSubject = new Subject5();
  const ignoreTransactionSubject = new Subject5();
  const interactionStatusChangeSubject = new Subject5();
  const gatewayModule = input.providers.gatewayModule;
  const dAppDefinitionAddress = input.dAppDefinitionAddress;
  const stateModule = input.providers.stateModule;
  const storageModule = input.providers.storageModule;
  const dataRequestStateModule = input.providers.dataRequestStateModule ?? DataRequestStateModule({});
  const requestItemModule = input.providers.requestItemModule ?? RequestItemModule({
    logger,
    providers: {
      storageModule: storageModule.getPartition("requests")
    }
  });
  const transports = input.providers.transports ?? [
    ConnectorExtensionModule({
      logger,
      providers: { requestItemModule, storageModule }
    }),
    RadixConnectRelayModule({
      logger,
      walletUrl: "radixWallet://connect",
      baseUrl: "https://radix-connect-relay.radixdlt.com",
      dAppDefinitionAddress: input.dAppDefinitionAddress,
      providers: {
        requestItemModule,
        storageModule
      }
    })
  ];
  const walletRequestSdk = input.providers.walletRequestSdk ?? WalletRequestSdk({
    logger,
    networkId,
    origin: input.origin,
    dAppDefinitionAddress,
    requestInterceptor: input.requestInterceptor,
    providers: { transports }
  });
  const cancelRequestControl = (id) => {
    const messageLifeCycleEvent = new Subject5();
    return {
      eventCallback: (event) => {
        messageLifeCycleEvent.next(event);
      },
      requestControl: ({ cancelRequest: cancelRequest2, getRequest }) => {
        firstValueFrom4(
          messageLifeCycleEvent.pipe(
            filter5((event) => event === "receivedByWallet"),
            map4(() => getRequest()),
            tap2((request) => {
              if (request.items.discriminator === "transaction")
                requestItemModule.patch(id, { showCancel: false });
            })
          )
        );
        firstValueFrom4(
          cancelRequestSubject.pipe(
            filter5((requestItemId) => requestItemId === id),
            switchMap5(
              () => requestItemModule.cancel(id).andThen(() => cancelRequest2())
            )
          )
        );
        firstValueFrom4(
          ignoreTransactionSubject.pipe(
            filter5((requestItemId) => requestItemId === id),
            switchMap5(
              () => requestItemModule.updateStatus({
                id,
                status: "ignored"
              }).andThen(() => cancelRequest2())
            )
          )
        );
      }
    };
  };
  let challengeGeneratorFn = () => Promise.resolve("");
  let connectResponseCallback;
  let dataRequestControl;
  const isChallengeNeeded = (dataRequestState) => dataRequestState.accounts?.withProof || dataRequestState.persona?.withProof;
  const getChallenge = (dataRequestState) => {
    if (!isChallengeNeeded(dataRequestState))
      return okAsync10(void 0);
    return ResultAsync11.fromPromise(
      challengeGeneratorFn(),
      () => SdkError("ChallengeGeneratorError", "", "failed to generate challenge")
    ).andThen(
      (challenge) => validateRolaChallenge(challenge) ? ok14(challenge) : err12(SdkError("ChallengeValidationError", "", "challenge is invalid"))
    );
  };
  const provideConnectResponseCallback = (fn) => {
    connectResponseCallback = (result) => fn(result);
  };
  const provideDataRequestControl = (fn) => {
    dataRequestControl = (walletData) => ResultAsync11.fromPromise(fn(walletData), () => ({
      error: "LoginRejectedByDapp",
      message: "Login rejected by dApp"
    }));
  };
  const sendOneTimeRequest = (...items) => sendRequest({
    dataRequestState: dataRequestStateModule.toDataRequestState(...items),
    isConnect: false,
    oneTime: true
  });
  const resolveWalletResponse = (walletInteraction, walletInteractionResponse) => {
    if (walletInteractionResponse.discriminator === "success" && walletInteractionResponse.items.discriminator === "authorizedRequest") {
      return ResultAsync11.combine([
        transformWalletResponseToRdtWalletData(walletInteractionResponse.items),
        stateModule.getState()
      ]).andThen(([walletData, state]) => {
        return stateModule.setState({
          loggedInTimestamp: Date.now().toString(),
          walletData,
          sharedData: transformWalletRequestToSharedData(
            walletInteraction,
            state.sharedData
          )
        }).andThen(
          () => requestItemModule.updateStatus({
            id: walletInteractionResponse.interactionId,
            status: "success"
          })
        );
      });
    }
    return okAsync10(void 0);
  };
  const sendDataRequest = (walletInteraction) => {
    return walletRequestSdk.request(
      walletInteraction,
      cancelRequestControl(walletInteraction.interactionId)
    ).map((response) => {
      logger?.debug({ method: "sendDataRequest.successResponse", response });
      return response;
    }).mapErr((error) => {
      logger?.debug({ method: "sendDataRequest.errorResponse", error });
      requestItemModule.updateStatus({
        id: walletInteraction.interactionId,
        status: "fail",
        error: error.error
      });
      return error;
    });
  };
  const sendRequest = ({
    isConnect,
    oneTime,
    dataRequestState
  }) => {
    return ResultAsync11.combine([
      getChallenge(dataRequestState),
      stateModule.getState().mapErr(() => SdkError("FailedToReadRdtState", ""))
    ]).andThen(
      ([challenge, state]) => toWalletRequest({
        dataRequestState,
        isConnect,
        oneTime,
        challenge,
        walletData: state.walletData
      }).mapErr(() => SdkError("FailedToTransformWalletRequest", "")).asyncAndThen((walletDataRequest) => {
        const walletInteraction = walletRequestSdk.createWalletInteraction(walletDataRequest);
        if (canDataRequestBeResolvedByRdtState(walletDataRequest, state) && useCache)
          return okAsync10(state.walletData);
        const isLoginRequest = !state.walletData.persona && walletDataRequest.discriminator === "authorizedRequest";
        return requestItemModule.add({
          type: isLoginRequest ? "loginRequest" : "dataRequest",
          walletInteraction,
          isOneTimeRequest: oneTime
        }).mapErr(
          ({ message }) => SdkError(
            "FailedToCreateRequestItem",
            walletInteraction.interactionId,
            message
          )
        ).andThen(
          () => sendDataRequest(walletInteraction).andThen((walletInteractionResponse) => {
            if (walletInteractionResponse.discriminator === "success" && walletInteractionResponse.items.discriminator !== "transaction")
              return ok14(walletInteractionResponse.items);
            return err12(
              SdkError(
                "WalletResponseFailure",
                walletInteractionResponse.interactionId,
                "expected data response"
              )
            );
          }).andThen(transformWalletResponseToRdtWalletData).andThen((transformedWalletResponse) => {
            if (dataRequestControl)
              return dataRequestControl(transformedWalletResponse).andThen(
                () => requestItemModule.updateStatus({
                  id: walletInteraction.interactionId,
                  status: "success"
                }).mapErr(
                  (error) => SdkError(
                    error.reason,
                    walletInteraction.interactionId
                  )
                ).map(() => transformedWalletResponse)
              ).mapErr((error) => {
                requestItemModule.updateStatus({
                  id: walletInteraction.interactionId,
                  status: "fail",
                  error: error.error
                });
                return SdkError(
                  error.error,
                  walletInteraction.interactionId
                );
              });
            return requestItemModule.updateStatus({
              id: walletInteraction.interactionId,
              status: "success"
            }).map(() => transformedWalletResponse).mapErr(
              (error) => SdkError(error.reason, walletInteraction.interactionId)
            );
          }).map((transformedWalletResponse) => {
            interactionStatusChangeSubject.next("success");
            if (!oneTime) {
              stateModule.setState({
                loggedInTimestamp: Date.now().toString(),
                walletData: transformedWalletResponse,
                sharedData: transformWalletRequestToSharedData(
                  walletInteraction,
                  state.sharedData
                )
              }).map(() => {
                stateModule.emitWalletData();
              });
            }
            return transformedWalletResponse;
          }).mapErr((err14) => {
            interactionStatusChangeSubject.next("fail");
            return err14;
          })
        );
      })
    ).mapErr((error) => {
      logger?.error(error);
      return error;
    });
  };
  const setRequestDataState = (...items) => {
    dataRequestStateModule.setState(...items);
    return {
      sendRequest: () => sendRequest({
        dataRequestState: dataRequestStateModule.getState(),
        isConnect: false,
        oneTime: false
      })
    };
  };
  const updateSharedAccounts = () => stateModule.getState().mapErr((err14) => {
    logger?.error(err14);
    return {
      error: "FailedToReadRdtState",
      message: "failed to read rdt state",
      jsError: err14
    };
  }).andThen(
    (state) => sendRequest({
      dataRequestState: transformSharedDataToDataRequestState(
        state.sharedData
      ),
      isConnect: false,
      oneTime: false
    })
  );
  const subscriptions = new Subscription5();
  subscriptions.add(
    requestItemModule.requests$.pipe(
      mergeMap2((items) => {
        const unresolvedItems = items.filter((item) => item.status === "pending" && item.walletResponse).map(
          (item) => resolveWalletResponse(
            item.walletInteraction,
            item.walletResponse
          )
        );
        return ResultAsync11.combineWithAllErrors(unresolvedItems);
      })
    ).subscribe()
  );
  const sendTransaction = (value) => {
    const walletInteraction = walletRequestSdk.createWalletInteraction({
      discriminator: "transaction",
      send: {
        blobs: value.blobs,
        transactionManifest: value.transactionManifest,
        message: value.message,
        version: value.version ?? 1
      }
    });
    requestItemModule.add({
      type: "sendTransaction",
      walletInteraction,
      isOneTimeRequest: false
    });
    return walletRequestSdk.sendTransaction(
      walletInteraction,
      cancelRequestControl(walletInteraction.interactionId)
    ).mapErr((response) => {
      requestItemModule.updateStatus({
        id: walletInteraction.interactionId,
        status: "fail",
        error: response.error
      });
      interactionStatusChangeSubject.next("fail");
      logger?.debug({ method: "sendTransaction.errorResponse", response });
      return response;
    }).andThen(
      (response) => {
        logger?.debug({ method: "sendTransaction.successResponse", response });
        if (response.discriminator === "success" && response.items.discriminator === "transaction")
          return ok14(response.items.send);
        if (response.discriminator === "failure")
          return err12(
            SdkError(
              response.error,
              response.interactionId,
              response.message
            )
          );
        return err12(SdkError("WalletResponseFailure", response.interactionId));
      }
    ).andThen(({ transactionIntentHash }) => {
      if (value.onTransactionId)
        value.onTransactionId(transactionIntentHash);
      return gatewayModule.pollTransactionStatus(transactionIntentHash).map((transactionStatusResponse) => ({
        transactionIntentHash,
        status: transactionStatusResponse.status
      }));
    }).andThen((response) => {
      const failedTransactionStatus = [
        TransactionStatus.Rejected,
        TransactionStatus.CommittedFailure
      ];
      const isFailedTransaction = failedTransactionStatus.includes(
        response.status
      );
      logger?.debug({
        method: "sendTransaction.pollTransactionStatus.completed",
        response
      });
      const status = isFailedTransaction ? "fail" : "success";
      return requestItemModule.updateStatus({
        id: walletInteraction.interactionId,
        status,
        transactionIntentHash: response.transactionIntentHash
      }).mapErr(
        () => SdkError(
          "FailedToUpdateRequestItem",
          walletInteraction.interactionId
        )
      ).andThen(() => {
        interactionStatusChangeSubject.next(status);
        return isFailedTransaction ? err12(
          SdkError(
            "TransactionNotSuccessful",
            walletInteraction.interactionId
          )
        ) : ok14(response);
      });
    });
  };
  const getTransport = () => transports.find((transport) => transport.isSupported());
  const getPendingRequests = () => requestItemModule.getPending();
  const cancelRequest = (id) => {
    cancelRequestSubject.next(id);
    requestItemModule.cancel(id);
    interactionStatusChangeSubject.next("fail");
  };
  const ignoreTransaction = (id) => {
    ignoreTransactionSubject.next(id);
    requestItemModule.updateStatus({
      id,
      status: "ignored"
    });
    interactionStatusChangeSubject.next("fail");
  };
  const provideChallengeGenerator = (fn) => {
    challengeGeneratorFn = fn;
  };
  const disconnect = () => {
    requestItemModule.getPending().map((items) => {
      items.forEach((item) => {
        if (item.showCancel)
          cancelRequestSubject.next(item.interactionId);
      });
    });
    stateModule.reset();
    requestItemModule.clear();
    transports.forEach((transport) => transport?.disconnect());
  };
  const destroy = () => {
    stateModule.destroy();
    requestItemModule.destroy();
    input.providers.transports?.forEach((transport) => transport.destroy());
    subscriptions.unsubscribe();
  };
  return {
    sendRequest: (input2) => {
      const result = sendRequest({
        isConnect: input2.isConnect,
        oneTime: input2.oneTime,
        dataRequestState: dataRequestStateModule.getState()
      });
      if (connectResponseCallback)
        result.map((result2) => {
          connectResponseCallback(ok14(result2));
        }).mapErr((error) => {
          connectResponseCallback(err12(error));
        });
      return result;
    },
    sendTransaction,
    cancelRequest,
    ignoreTransaction,
    requestItemModule,
    provideChallengeGenerator,
    provideDataRequestControl,
    provideConnectResponseCallback,
    sendOneTimeRequest,
    setRequestDataState,
    getPendingRequests,
    getTransport,
    updateSharedAccounts,
    dataRequestStateModule,
    interactionStatusChange$: interactionStatusChangeSubject.asObservable(),
    requestItems$: requestItemModule.requests$,
    disconnect,
    destroy
  };
};

// src/helpers/is-browser.ts
var isBrowser = () => ![typeof window, typeof document].includes("undefined");

// src/modules/connect-button/connect-button-noop.module.ts
import { NEVER } from "rxjs";
var ConnectButtonNoopModule = () => {
  return {
    status$: NEVER,
    onConnect$: NEVER,
    onDisconnect$: NEVER,
    onUpdateSharedAccounts$: NEVER,
    onShowPopover$: NEVER,
    onCancelRequestItem$: NEVER,
    onLinkClick$: NEVER,
    setStatus: () => {
    },
    setMode: () => {
    },
    setTheme: () => {
    },
    setActiveTab: () => {
    },
    setIsMobile: () => {
    },
    setIsWalletLinked: () => {
    },
    setIsExtensionAvailable: () => {
    },
    setConnected: () => {
    },
    setLoggedInTimestamp: () => {
    },
    setRequestItems: () => {
    },
    setAccounts: () => {
    },
    setPersonaData: () => {
    },
    setPersonaLabel: () => {
    },
    setDappName: () => {
    },
    destroy: () => {
    },
    disconnect: () => {
    }
  };
};

// src/modules/connect-button/connect-button.module.ts
var ConnectButtonModule = (input) => {
  if (!isBrowser()) {
    return ConnectButtonNoopModule();
  }
  import("./connect-button-LXZ2YJET.js");
  const logger = input?.logger?.getSubLogger({ name: "ConnectButtonModule" });
  const subjects = input.subjects || ConnectButtonSubjects();
  const dAppDefinitionAddress = input.dAppDefinitionAddress;
  const { baseUrl, accountsPath, transactionPath } = input.explorer ?? {
    baseUrl: RadixNetworkConfigById[input.networkId].dashboardUrl,
    transactionPath: "/transaction/",
    accountsPath: "/account/"
  };
  const statusStorage = input.providers.storageModule;
  const stateModule = input.providers.stateModule;
  const gatewayModule = input.providers.gatewayModule;
  const walletRequestModule = input.providers.walletRequestModule;
  const onConnectDefault = (done) => {
    done();
  };
  const onConnect = input.onConnect || onConnectDefault;
  const transport = walletRequestModule.getTransport();
  const getConnectButtonElement = () => document.querySelector("radix-connect-button");
  const subscriptions = new Subscription6();
  const onConnectButtonRender$ = fromEvent(window, "onConnectButtonRender");
  subscriptions.add(
    onConnectButtonRender$.pipe(
      map5(() => getConnectButtonElement()),
      filter6((element) => !!element),
      switchMap6((connectButtonElement) => {
        logger?.debug({ observable: `onConnectButtonRender$` });
        const onConnect$ = fromEvent(connectButtonElement, "onConnect").pipe(
          tap3(() => {
            onConnect((value) => subjects.onConnect.next(value));
          })
        );
        const onDisconnect$ = fromEvent(
          connectButtonElement,
          "onDisconnect"
        ).pipe(tap3(() => subjects.onDisconnect.next()));
        const onLinkClick$ = fromEvent(connectButtonElement, "onLinkClick").pipe(
          tap3((ev) => {
            subjects.onLinkClick.next(ev.detail);
          })
        );
        const onDestroy$ = fromEvent(connectButtonElement, "onDestroy").pipe(
          map5(() => {
            logger?.debug({ observable: `onDestroy$` });
            return true;
          })
        );
        const onCancelRequestItem$ = fromEvent(
          connectButtonElement,
          "onCancelRequestItem"
        ).pipe(
          tap3((event) => {
            const id = event.detail.id;
            logger?.debug({ method: "onCancelRequestItem", id });
            subjects.onCancelRequestItem.next(id);
          })
        );
        const onIgnoreTransactionItem$ = fromEvent(
          connectButtonElement,
          "onIgnoreTransactionItem"
        ).pipe(
          tap3((event) => {
            const id = event.detail.id;
            logger?.debug({
              method: "onIgnoreTransactionItem",
              id
            });
            subjects.onIgnoreTransactionItem.next(id);
          })
        );
        const onUpdateSharedAccounts$ = fromEvent(
          connectButtonElement,
          "onUpdateSharedAccounts"
        ).pipe(
          tap3(() => {
            logger?.debug(`onUpdateSharedAccounts`);
            subjects.onUpdateSharedAccounts.next();
          })
        );
        const onShowPopover$ = fromEvent(
          connectButtonElement,
          "onShowPopover"
        ).pipe(tap3(() => subjects.onShowPopover.next()));
        const isWalletLinked$ = subjects.isWalletLinked.pipe(
          tap3((value) => connectButtonElement.isWalletLinked = value)
        );
        const isExtensionAvailable$ = subjects.isExtensionAvailable.pipe(
          tap3((value) => connectButtonElement.isExtensionAvailable = value)
        );
        const status$ = subjects.status.pipe(
          tap3((value) => connectButtonElement.status = value)
        );
        const mode$ = subjects.mode.pipe(
          tap3((value) => connectButtonElement.mode = value)
        );
        const connected$ = subjects.connected.pipe(
          tap3((value) => connectButtonElement.connected = value)
        );
        const isMobile$ = subjects.isMobile.pipe(
          tap3((value) => connectButtonElement.isMobile = value)
        );
        const loggedInTimestamp$ = subjects.loggedInTimestamp.pipe(
          tap3((value) => connectButtonElement.loggedInTimestamp = value)
        );
        const activeTab$ = subjects.activeTab.pipe(
          tap3((value) => connectButtonElement.activeTab = value)
        );
        const requestItems$ = subjects.requestItems.pipe(
          tap3((items) => connectButtonElement.requestItems = items)
        );
        const showPopoverMenu$ = subjects.showPopoverMenu.pipe(
          tap3((value) => {
            value ? connectButtonElement.setAttribute("showPopoverMenu", "true") : connectButtonElement.removeAttribute("showPopoverMenu");
          })
        );
        const accounts$ = subjects.accounts.pipe(
          tap3((items) => connectButtonElement.accounts = items)
        );
        const personaData$ = subjects.personaData.pipe(
          tap3((items) => connectButtonElement.personaData = items)
        );
        const personaLabel$ = subjects.personaLabel.pipe(
          tap3((items) => connectButtonElement.personaLabel = items)
        );
        const dAppName$ = subjects.dAppName.pipe(
          tap3((value) => connectButtonElement.dAppName = value)
        );
        const theme$ = subjects.theme.pipe(
          tap3((value) => connectButtonElement.theme = value)
        );
        const connectButtonEvents$ = merge4(
          onConnect$,
          status$,
          theme$,
          mode$,
          connected$,
          showPopoverMenu$,
          requestItems$,
          loggedInTimestamp$,
          isMobile$,
          activeTab$,
          isWalletLinked$,
          isExtensionAvailable$,
          onDisconnect$,
          onCancelRequestItem$,
          onIgnoreTransactionItem$,
          accounts$,
          personaData$,
          personaLabel$,
          onUpdateSharedAccounts$,
          onShowPopover$,
          dAppName$,
          onLinkClick$
        ).pipe(map5(() => false));
        return merge4(connectButtonEvents$, onDestroy$).pipe(
          filter6((shouldDestroy) => !!shouldDestroy),
          first3(),
          finalize(() => {
            logger?.debug({ observable: `onConnectButtonRender$.finalize` });
          })
        );
      })
    ).subscribe()
  );
  subscriptions.add(
    (transport && transport.isAvailable$ || of3(true)).pipe(tap3((value) => subjects.isExtensionAvailable.next(value))).subscribe()
  );
  subscriptions.add(
    (transport && transport.isLinked$ || of3(true)).pipe(tap3((value) => subjects.isWalletLinked.next(value))).subscribe()
  );
  subscriptions.add(
    subjects.onLinkClick.pipe(
      tap3(({ type, data }) => {
        if (["account", "transaction"].includes(type)) {
          if (!baseUrl || !window)
            return;
          const url = `${baseUrl}${type === "transaction" ? transactionPath : accountsPath}${data}`;
          window.open(url);
        } else if (type === "setupGuide")
          window.open("https://wallet.radixdlt.com");
        else if (type === "getWallet") {
          window.open("https://app.radixdlt.com/qr-code");
        } else if (type === "showQrCode" && transport?.showQrCode)
          transport.showQrCode();
      })
    ).subscribe()
  );
  const connectButtonApi = {
    status$: subjects.status.asObservable(),
    onConnect$: subjects.onConnect.asObservable(),
    onDisconnect$: subjects.onDisconnect.asObservable(),
    onShowPopover$: subjects.onShowPopover.asObservable(),
    onUpdateSharedAccounts$: subjects.onUpdateSharedAccounts.asObservable(),
    onCancelRequestItem$: subjects.onCancelRequestItem.asObservable(),
    onIgnoreTransactionItem$: subjects.onIgnoreTransactionItem.asObservable(),
    onLinkClick$: subjects.onLinkClick.asObservable(),
    setStatus: (value) => subjects.status.next(value),
    setTheme: (value) => subjects.theme.next(value),
    setMode: (value) => subjects.mode.next(value),
    setActiveTab: (value) => subjects.activeTab.next(value),
    setIsMobile: (value) => subjects.isMobile.next(value),
    setIsWalletLinked: (value) => subjects.isWalletLinked.next(value),
    setIsExtensionAvailable: (value) => subjects.isExtensionAvailable.next(value),
    setLoggedInTimestamp: (value) => subjects.loggedInTimestamp.next(value),
    setConnected: (value) => subjects.connected.next(value),
    setShowPopoverMenu: (value) => subjects.showPopoverMenu.next(value),
    setRequestItems: (items) => subjects.requestItems.next(items),
    setAccounts: (accounts2) => subjects.accounts.next(accounts2),
    setPersonaData: (personaData2) => subjects.personaData.next(personaData2),
    setPersonaLabel: (personaLabel) => subjects.personaLabel.next(personaLabel),
    setDappName: (dAppName) => subjects.dAppName.next(dAppName),
    disconnect: () => {
      subjects.connected.next(false);
      subjects.status.next("default");
    },
    destroy: () => {
      subscriptions.unsubscribe();
    }
  };
  const setPropsFromState = () => stateModule.getState().map((state) => {
    const { personaData: personaData2, accounts: accounts2, personaLabel, connected } = transformWalletDataToConnectButton(state.walletData);
    connectButtonApi.setLoggedInTimestamp(state.loggedInTimestamp);
    connectButtonApi.setAccounts(accounts2);
    connectButtonApi.setPersonaData(personaData2);
    connectButtonApi.setPersonaLabel(personaLabel);
    connectButtonApi.setConnected(connected);
  });
  subscriptions.add(
    stateModule.storage$.pipe(switchMap6(() => setPropsFromState())).subscribe()
  );
  subscriptions.add(
    subjects.onCancelRequestItem.pipe(
      tap3((value) => {
        walletRequestModule.cancelRequest(value);
      })
    ).subscribe()
  );
  subscriptions.add(
    subjects.onIgnoreTransactionItem.pipe(
      tap3((value) => {
        walletRequestModule.ignoreTransaction(value);
      })
    ).subscribe()
  );
  subscriptions.add(
    walletRequestModule.requestItems$.pipe(
      tap3((items) => {
        const hasPendingItem = items.find((item) => item.status === "pending");
        if (hasPendingItem) {
          connectButtonApi.setStatus("pending");
        }
        connectButtonApi.setRequestItems([...items].reverse());
      })
    ).subscribe()
  );
  subscriptions.add(
    subjects.onShowPopover.pipe(
      tap3(() => {
        walletRequestModule.getPendingRequests().map((pendingRequests) => {
          if (pendingRequests.length > 0) {
            subjects.activeTab.next("requests");
          }
        });
      })
    ).subscribe()
  );
  subscriptions.add(
    subjects.onConnect.pipe(
      switchMap6(
        () => stateModule.reset().andThen(
          () => walletRequestModule.sendRequest({
            isConnect: true,
            oneTime: false
          })
        ).map(() => isMobile() && subjects.showPopoverMenu.next(false))
      )
    ).subscribe()
  );
  subscriptions.add(
    subjects.onUpdateSharedAccounts.pipe(switchMap6(() => walletRequestModule.updateSharedAccounts())).subscribe()
  );
  subscriptions.add(
    subjects.onDisconnect.pipe(
      tap3(() => {
        subjects.connected.next(false);
        subjects.status.next("default");
        walletRequestModule.disconnect();
        if (input.onDisconnect)
          input.onDisconnect();
      })
    ).subscribe()
  );
  subscriptions.add(
    statusStorage.storage$.pipe(
      switchMap6(
        () => statusStorage.getState().map((state) => {
          if (state?.status) {
            subjects.status.next(state.status);
          }
        })
      )
    ).subscribe()
  );
  subscriptions.add(
    walletRequestModule.interactionStatusChange$.pipe(
      mergeMap3((newStatus) => {
        statusStorage.setState({
          status: newStatus === "success" ? "success" : "error"
        });
        return timer3(2e3).pipe(
          tap3(() => {
            const result = walletRequestModule.getPendingRequests();
            result.map((pendingItems) => {
              statusStorage.setState({
                status: pendingItems.length ? "pending" : "default"
              });
            });
          })
        );
      })
    ).subscribe()
  );
  if (dAppDefinitionAddress) {
    gatewayModule.gatewayApi.getEntityMetadataPage(dAppDefinitionAddress).map(
      (details) => details?.items.find((item) => item.key === "name")?.value?.typed?.value
    ).map((dAppName) => {
      subjects.dAppName.next(dAppName ?? "Unnamed dApp");
    });
  }
  return connectButtonApi;
};

// src/modules/connect-button/types.ts
var ConnectButtonStatus = {
  pending: "pending",
  success: "success",
  default: "default",
  error: "error"
};

// src/modules/storage/local-storage.module.ts
import { err as err13, ok as ok15, Result as Result8, ResultAsync as ResultAsync12 } from "neverthrow";
import { filter as filter7, fromEvent as fromEvent2, map as map6, merge as merge5, mergeMap as mergeMap4, of as of4 } from "rxjs";
var LocalStorageModule = (key, partitionKey) => {
  const storageKey = partitionKey ? `${key}:${partitionKey}` : key;
  const getDataAsync = () => new Promise((resolve, reject) => {
    try {
      resolve(localStorage.getItem(storageKey));
    } catch (error) {
      reject(error);
    }
  });
  const setDataAsync = (value) => new Promise((resolve, reject) => {
    try {
      localStorage.setItem(storageKey, value);
      resolve();
    } catch (error) {
      reject(error);
    }
  });
  const getItems = () => ResultAsync12.fromPromise(getDataAsync(), typedError).andThen(
    (data) => data ? parseJSON(data) : ok15({})
  );
  const getState = () => ResultAsync12.fromPromise(getDataAsync(), typedError).andThen(
    (data) => data ? parseJSON(data) : ok15(void 0)
  );
  const getItemById = (id) => ResultAsync12.fromPromise(getDataAsync(), typedError).andThen((data) => data ? parseJSON(data) : ok15(void 0)).map((items) => items ? items[id] : void 0);
  const removeItemById = (id) => getItems().andThen((items) => {
    const { [id]: _, ...newItems } = items;
    return stringify(newItems).asyncAndThen((serialized) => {
      const result = ResultAsync12.fromPromise(
        setDataAsync(serialized),
        typedError
      ).map(() => {
        window.dispatchEvent(
          new StorageEvent("storage", {
            key: storageKey,
            oldValue: JSON.stringify(items),
            newValue: serialized
          })
        );
      });
      return result;
    });
  });
  const patchItem = (id, patch) => getItemById(id).andThen((item) => {
    return item ? setItems({ [id]: { ...item, ...patch } }) : err13(new Error("Item not found"));
  });
  const setItems = (item) => getItems().andThen(
    (data) => stringify({ ...data, ...item }).asyncAndThen((serialized) => {
      const result = ResultAsync12.fromPromise(
        setDataAsync(serialized),
        typedError
      ).map(() => {
        window.dispatchEvent(
          new StorageEvent("storage", {
            key: storageKey,
            oldValue: JSON.stringify(data),
            newValue: serialized
          })
        );
      });
      return result;
    })
  );
  const getItemList = () => getItems().map(Object.values);
  const setState = (newValue) => getState().andThen(
    (oldValue) => stringify({ ...oldValue ?? {}, ...newValue }).asyncAndThen(
      (serialized) => {
        const result = ResultAsync12.fromPromise(
          setDataAsync(serialized),
          typedError
        ).map(() => {
          window.dispatchEvent(
            new StorageEvent("storage", {
              key: storageKey,
              oldValue: JSON.stringify(oldValue),
              newValue: serialized
            })
          );
        });
        return result;
      }
    )
  );
  const patchState = (newValue) => getState().mapErr(() => ({ reason: "FailedToReadFromLocalStorage" })).andThen(
    (oldState) => oldState ? setState({ ...oldState, ...newValue }).mapErr(() => ({
      reason: "FailedToWriteToLocalStorage"
    })) : err13({ reason: "PatchingStateFailed" })
  );
  const getPartition = (partitionKey2) => LocalStorageModule(key, partitionKey2);
  const storage$ = merge5(
    fromEvent2(window, "storage"),
    of4({ key: storageKey, newValue: null, oldValue: null })
  ).pipe(
    filter7((item) => item.key === storageKey),
    mergeMap4((event) => {
      const { key: key2, newValue, oldValue } = event;
      if (!key2)
        return [];
      const [rdt, accountDefinition, networkId, partition] = key2.split(":");
      if (rdt === "rdt" && accountDefinition && networkId) {
        const oldValueResult = oldValue ? parseJSON(oldValue) : ok15(void 0);
        const newValueResult = newValue ? parseJSON(newValue) : ok15(void 0);
        return [
          Result8.combine([oldValueResult, newValueResult]).map(
            ([oldValue2, newValue2]) => ({
              key: key2,
              partition,
              newValue: newValue2,
              oldValue: oldValue2
            })
          )
        ];
      }
      return [];
    }),
    filter7((result) => result.isOk()),
    map6(({ value }) => value)
  );
  const clear = () => ResultAsync12.fromPromise(
    new Promise((resolve) => resolve(localStorage.removeItem(storageKey))),
    typedError
  );
  return {
    getItems,
    getItemById,
    removeItemById,
    patchItem,
    setItems,
    getItemList,
    getPartition,
    setState,
    getState,
    patchState,
    clear,
    storage$
  };
};

// src/radix-dapp-toolkit.ts
polyfills_default();
var RadixDappToolkit = (options) => {
  const dAppDefinitionAddress = options.dAppDefinitionAddress ?? options.applicationDappDefinitionAddress;
  const {
    networkId,
    providers,
    logger,
    onDisconnect,
    gatewayBaseUrl,
    applicationName,
    applicationVersion,
    useCache = true
  } = options || {};
  const storageModule = providers?.storageModule ?? LocalStorageModule(`rdt:${dAppDefinitionAddress}:${networkId}`);
  const stateModule = providers?.stateModule ?? StateModule({
    logger,
    providers: {
      storageModule: storageModule.getPartition("state")
    }
  });
  const gatewayModule = providers?.gatewayModule ?? GatewayModule({
    logger,
    clientConfig: generateGatewayApiConfig({
      networkId,
      dAppDefinitionAddress,
      gatewayBaseUrl,
      applicationName,
      applicationVersion
    })
  });
  const walletRequestModule = providers?.walletRequestModule ?? WalletRequestModule({
    logger,
    useCache,
    networkId,
    dAppDefinitionAddress,
    requestInterceptor: options.requestInterceptor,
    providers: {
      stateModule,
      storageModule,
      gatewayModule
    }
  });
  const connectButtonModule = providers?.connectButtonModule ?? ConnectButtonModule({
    logger,
    networkId,
    explorer: options.explorer,
    onDisconnect,
    dAppDefinitionAddress,
    providers: {
      stateModule,
      walletRequestModule,
      gatewayModule,
      storageModule: storageModule.getPartition("connectButton")
    }
  });
  return {
    walletApi: {
      setRequestData: walletRequestModule.setRequestDataState,
      sendRequest: () => walletRequestModule.sendRequest({
        isConnect: false,
        oneTime: false
      }),
      provideChallengeGenerator: (fn) => walletRequestModule.provideChallengeGenerator(fn),
      dataRequestControl: (fn) => {
        walletRequestModule.provideDataRequestControl(fn);
      },
      provideConnectResponseCallback: walletRequestModule.provideConnectResponseCallback,
      updateSharedAccounts: () => walletRequestModule.updateSharedAccounts(),
      sendOneTimeRequest: walletRequestModule.sendOneTimeRequest,
      sendTransaction: (input) => walletRequestModule.sendTransaction(input),
      walletData$: stateModule.walletData$,
      getWalletData: stateModule.getWalletData
    },
    buttonApi: {
      setTheme: connectButtonModule.setTheme,
      setMode: connectButtonModule.setMode,
      status$: connectButtonModule.status$
    },
    gatewayApi: {
      clientConfig: gatewayModule.configuration
    },
    disconnect: () => {
      walletRequestModule.disconnect();
      connectButtonModule.disconnect();
      if (onDisconnect)
        onDisconnect();
    },
    destroy: () => {
      stateModule.destroy();
      walletRequestModule.destroy();
      connectButtonModule.destroy();
    }
  };
};
export {
  Account,
  AccountProof,
  AccountsRequestItem,
  AccountsRequestResponseItem,
  AnswerIO,
  AuthLoginRequestItem,
  AuthLoginRequestResponseItem,
  AuthLoginWithChallengeRequestItem,
  AuthLoginWithChallengeRequestResponseItem,
  AuthLoginWithoutChallengeRequestItem,
  AuthLoginWithoutChallengeRequestResponseItem,
  AuthRequestItem,
  AuthRequestResponseItem,
  AuthUsePersonaRequestItem,
  CancelRequest,
  CancelWalletInteractionExtensionInteraction,
  ConnectButtonModule,
  ConnectButtonStatus,
  ConnectButtonSubjects,
  ConnectorExtensionModule,
  ConnectorExtensionSubjects,
  Curve25519,
  DataRequestBuilder,
  DataRequestStateModule,
  DeepLinkModule,
  ExponentialBackoff,
  ExtensionInteraction,
  GatewayApiService,
  GatewayModule,
  IceCandidateIO,
  IceCandidatePayloadIO,
  IceCandidatesIO,
  IdentityKind,
  IdentityModule,
  LocalStorageModule,
  Logger,
  LoginRequestResponseItem,
  MessageLifeCycleEvent,
  MessageLifeCycleExtensionStatusEvent,
  Metadata,
  NumberOfValues,
  OfferIO,
  OneTimeDataRequestBuilder,
  OpenPopupExtensionInteraction,
  Persona,
  PersonaDataName,
  PersonaDataNameVariant,
  PersonaDataRequestItem,
  PersonaDataRequestResponseItem,
  Proof,
  RadixConnectRelayModule,
  RadixDappToolkit,
  RadixNetwork,
  RadixNetworkConfig,
  RadixNetworkConfigById,
  RdtState,
  RequestItemModule,
  ResetRequestItem,
  SendTransactionItem,
  SendTransactionResponseItem,
  SessionModule,
  SharedData,
  SignalingServerMessage,
  SignedChallenge,
  SignedChallengeAccount,
  SignedChallengePersona,
  Sources,
  StateModule,
  StatusExtensionInteraction,
  TransactionStatus,
  TransformRdtDataRequestToWalletRequestInput,
  WalletAuthorizedRequestItems,
  WalletAuthorizedRequestResponseItems,
  WalletData,
  WalletDataPersonaData,
  WalletDataPersonaDataEmailAddresses,
  WalletDataPersonaDataFullName,
  WalletDataPersonaDataPhoneNumbersAddresses,
  WalletInteraction,
  WalletInteractionExtensionInteraction,
  WalletInteractionFailureResponse,
  WalletInteractionItems,
  WalletInteractionResponse,
  WalletInteractionSuccessResponse,
  WalletRequestItems,
  WalletRequestModule,
  WalletRequestResponseItems,
  WalletRequestSdk,
  WalletTransactionItems,
  WalletUnauthorizedRequestItems,
  blake2b,
  canDataRequestBeResolvedByRdtState,
  config,
  eventType,
  extensionInteractionDiscriminator,
  fetchWrapper,
  generateGatewayApiConfig,
  generateRolaChallenge,
  isMobile,
  messageLifeCycleEventType,
  parseJSON,
  parseSignedChallenge,
  personaDataFullNameVariant,
  proofType,
  removeUndefined,
  stringify,
  toWalletRequest,
  transformRdtDataRequestToWalletRequest,
  transformSharedDataToDataRequestState,
  transformWalletDataToConnectButton,
  transformWalletRequestToSharedData,
  transformWalletResponseToRdtWalletData,
  typedError,
  unwrapObservable,
  validateRolaChallenge,
  validateWalletResponse,
  walletDataDefault
};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
